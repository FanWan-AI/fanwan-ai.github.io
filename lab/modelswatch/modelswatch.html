<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-i18n="modelwatch_title">模型追踪器</title>
  <link rel="icon" href="../../assets/logo.svg" type="image/svg+xml">
  <meta name="theme-color" content="#0ea5e9">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://busuanzi.ibruce.info; font-src 'self' data:; connect-src 'self' https://busuanzi.ibruce.info; base-uri 'self'; object-src 'none'">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="description" content="模型追踪器：跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <link rel="canonical" href="https://fanwan-ai.github.io/lab/modelswatch/modelswatch.html">
  <meta property="og:type" content="website">
  <meta property="og:title" content="模型追踪器" data-i18n-content="modelwatch_title">
  <meta property="og:description" content="跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <meta property="og:image" content="https://fanwan-ai.github.io/assets/placeholder.jpg">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:image:alt" content="Model Watch cover">
  <meta property="og:url" content="https://fanwan-ai.github.io/lab/modelswatch/modelswatch.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="模型追踪器" data-i18n-content="modelwatch_title">
  <meta name="twitter:description" content="跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <meta name="twitter:image" content="https://fanwan-ai.github.io/assets/placeholder.jpg">
  <script>try{var L=localStorage.getItem('lang')||document.documentElement.lang||'zh';document.documentElement.setAttribute('lang',L);}catch(e){}</script>
  <link rel="stylesheet" href="../../style.css">
  <script defer src="../../lang.js"></script>
  <script defer src="../../script.js"></script>
  <style>
    .mw-wrap{max-width:1200px;margin:0 auto;padding:0 12px}
    /* Weekly summary block */
    #mw-weekly-summary{position:relative;margin:18px 0 24px;padding:18px 20px;border:1px solid color-mix(in oklab,var(--border),var(--primary) 20%);border-radius:18px;background:linear-gradient(145deg,color-mix(in oklab,var(--surface-2),var(--primary) 4%),color-mix(in oklab,var(--surface-2),var(--primary) 10%));box-shadow:0 6px 18px -4px rgba(37,99,235,.18),0 2px 4px rgba(0,0,0,.06);overflow:hidden}
    #mw-weekly-summary:before{content:"";position:absolute;right:-40px;top:-40px;width:180px;height:180px;background:radial-gradient(circle at 30% 30%,color-mix(in oklab,var(--primary) 65%,white 10%),transparent 70%);opacity:.18;pointer-events:none}
    #mw-weekly-summary h3{margin:0 0 10px;font-size:1.05rem;display:flex;align-items:center;gap:8px;font-weight:700;color:var(--secondary);letter-spacing:.5px}
    #mw-weekly-summary h3 svg{width:18px;height:18px;color:var(--primary)}
    #mw-weekly-summary .mw-summary-text{margin:0 0 10px;line-height:1.55;font-size:.92rem;white-space:pre-wrap}
    #mw-weekly-summary .mw-summary-tabs{display:flex;gap:6px;margin:0 0 10px;flex-wrap:wrap}
    #mw-weekly-summary .mw-summary-tabs button{border:1px solid color-mix(in oklab,var(--border),var(--primary) 25%);background:color-mix(in oklab,var(--surface),white 4%);padding:4px 10px;border-radius:999px;font-size:.7rem;font-weight:600;letter-spacing:.4px;cursor:pointer;display:inline-flex;align-items:center;gap:4px;color:var(--text)}
    #mw-weekly-summary .mw-summary-tabs button.active{background:linear-gradient(135deg,var(--primary) 0%,var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab,var(--primary-600),white 8%);box-shadow:0 4px 12px rgba(37,99,235,.35)}
    #mw-weekly-summary .mw-task-dist{display:flex;flex-wrap:wrap;gap:6px;margin:4px 0 0}
    #mw-weekly-summary .mw-task-pill{font-size:.62rem;padding:4px 8px;border:1px solid color-mix(in oklab,var(--primary) 55%,var(--border));border-radius:999px;background:color-mix(in oklab,var(--surface-2),var(--primary) 12%);font-weight:600;letter-spacing:.3px;display:inline-flex;align-items:center;gap:4px;line-height:1}
    #mw-weekly-summary .mw-task-pill span{color:color-mix(in oklab,var(--primary-700,#1d4ed8),black 5%)}
    :root[data-theme="dark"] #mw-weekly-summary{background:linear-gradient(145deg,color-mix(in oklab,var(--surface-2),black 8%),color-mix(in oklab,var(--surface-2),var(--primary-900,#1e3a8a) 35%));box-shadow:0 10px 28px -6px rgba(15,23,42,.6),0 4px 10px -2px rgba(0,0,0,.55)}
    :root[data-theme="dark"] #mw-weekly-summary .mw-task-pill{background:color-mix(in oklab,var(--primary-900,#1e3a8a),black 12%);color:#e2e8f0;border-color:color-mix(in oklab,var(--primary-500,#3b82f6),#1e293b 55%)}
    :root[data-theme="dark"] #mw-weekly-summary .mw-summary-tabs button{background:color-mix(in oklab,var(--surface-2),black 12%);color:#e2e8f0;border-color:color-mix(in oklab,var(--border),var(--primary) 28%)}
    :root[data-theme="dark"] #mw-weekly-summary .mw-summary-tabs button.active{background:linear-gradient(135deg,var(--primary-400,#60a5fa) 0%,var(--primary-700,#1d4ed8) 100%);color:#fff}
    #mw-weekly-summary .mw-empty{font-size:.8rem;color:var(--muted);margin:0}
    @media (max-width:680px){#mw-weekly-summary{padding:16px 16px;border-radius:16px}#mw-weekly-summary h3{font-size:1rem}#mw-weekly-summary .mw-summary-text{font-size:.9rem}}
    /* Toolbar layout */
  .mw-toolbar{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:center;padding:14px 12px}
  /* Modes row: first row full-width */
  .mw-modes{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;width:100%;margin-bottom:6px}
    /* Distinct, polished style for the three mode buttons (different from tag chips) */
    .mw-modes .btn{display:inline-flex;align-items:center;justify-content:center;height:44px;padding:0 18px;line-height:1;text-align:center;border-radius:999px;margin-right:0;font-weight:700;letter-spacing:.2px;min-width:180px;box-shadow:var(--shadow-sm);border:1px solid color-mix(in oklab, var(--border), var(--primary) 14%)}
    /* Active state: brand gradient pill */
    .mw-modes .btn.primary{background:linear-gradient(135deg, var(--primary) 0%, var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab, var(--primary-600), white 10%);box-shadow:0 8px 18px rgba(37,99,235,0.18)}
    .mw-modes .btn.primary:hover{transform:translateY(-1px);box-shadow:0 10px 22px rgba(37,99,235,0.24)}
    /* Inactive state: soft glass-like pill */
    .mw-modes .btn.outline{background:color-mix(in oklab, var(--surface), white 6%);color:color-mix(in oklab, var(--text), var(--muted) 12%);border-color:color-mix(in oklab, var(--border), var(--primary) 22%)}
    .mw-modes .btn.outline:hover{background:color-mix(in oklab, var(--surface), var(--primary) 8%);color:var(--text)}
    /* Dark theme tuning */
    :root[data-theme="dark"] .mw-modes .btn.primary{box-shadow:0 10px 24px rgba(59,130,246,0.25)}
    :root[data-theme="dark"] .mw-modes .btn.outline{background:color-mix(in oklab, var(--surface), black 6%);color:#e5e7eb;border-color:color-mix(in oklab, var(--border), var(--primary) 25%)}
    @media (max-width:560px){.mw-modes .btn{min-width:auto;flex:1 1 auto;padding:0 14px;height:42px}}
  /* Unified control sizing and aesthetics */
  :root{ --mw-ctrl-h: 38px; --mw-radius: 10px; }
  .mw-toolbar .input{height:var(--mw-ctrl-h);padding:6px 12px;border-radius:var(--mw-radius);border:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);background:color-mix(in oklab, var(--surface-2), white 2%);box-shadow:var(--shadow-sm)}
  .mw-toolbar .btn.small{height:var(--mw-ctrl-h);padding:0 12px;border-radius:var(--mw-radius)}
  /* Date group: segmented control with equal spacing */
  #mw-datewrap{gap:0!important;border:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-radius:var(--mw-radius);overflow:hidden;background:color-mix(in oklab, var(--surface-2), white 2%);box-shadow:var(--shadow-sm);padding:0 8px}
  #mw-datewrap .btn{border:none;border-right:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);width:var(--mw-ctrl-h);display:inline-grid;place-items:center;padding:0}
  #mw-datewrap .btn:last-child{border-right:none}
  #mw-datewrap .input{border:none;border-left:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-right:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-radius:0;height:var(--mw-ctrl-h);box-shadow:none;background:transparent}
  /* Cascader trigger: pill appearance */
  .mw-cas-inline > #mw-cas-trigger{font-weight:600}
  /* Active state for trigger when filters applied */
  .mw-cas-inline > #mw-cas-trigger.active{background:linear-gradient(135deg, var(--primary) 0%, var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab, var(--primary-600), white 10%);box-shadow:0 8px 18px rgba(37,99,235,.18)}
  /* Search input: add subtle search icon */
  #mw-q{padding-left:34px;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='none' stroke='%2399a3ad' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:10px center;color:var(--text)}
  #mw-q::placeholder{color:color-mix(in oklab, var(--muted), var(--text) 25%)}
  :root[data-theme="dark"] #mw-q{color:#111;background:#fff;border-color:color-mix(in oklab, var(--border), white 35%)}
  :root[data-theme="dark"] #mw-q::placeholder{color:#555}
  /* Dark theme cascader trigger & clear button accessibility */
  :root[data-theme="dark"] #mw-cas-trigger{background:#fff;color:#111;border:1px solid color-mix(in oklab,var(--border),white 35%);transition:background .15s,color .15s,border-color .15s}
  :root[data-theme="dark"] #mw-cas-trigger:hover{background:#f1f5f9}
  :root[data-theme="dark"] #mw-cas-trigger.active{background:#e2e8f0;border-color:#cbd5e1}
  :root[data-theme="dark"] #mw-cas-clear{background:#fff;color:#111;border:1px solid color-mix(in oklab,var(--border),white 35%)}
  :root[data-theme="dark"] #mw-cas-clear:hover{background:#fee2e2;color:#991b1b;border-color:#fca5a5}
  :root[data-theme="dark"] #mw-cas-clear:active{background:#fecaca}
  :root[data-theme="dark"] #mw-cas-clear:focus-visible{outline:2px solid #ef4444;outline-offset:2px}
  /* Date input contrast */
  #mw-date{color:var(--text);background:transparent}
  #mw-date::placeholder{color:color-mix(in oklab, var(--muted), var(--text) 30%)}
  :root[data-theme="dark"] #mw-date{color:#111;background:#fff;border:1px solid color-mix(in oklab, var(--border), white 35%);border-radius:var(--mw-radius)}
  :root[data-theme="dark"] #mw-date::placeholder{color:#555}
  :root[data-theme="dark"] #mw-sort{color:#111;background:#fff;border:1px solid color-mix(in oklab, var(--border), white 35%)}
  :root[data-theme="dark"] #mw-datewrap{background:#fff}
  :root[data-theme="dark"] #mw-datewrap .btn{background:#fff;color:#111}
  :root[data-theme="dark"] #mw-datewrap .btn:hover{background:#f2f2f2}
  :root[data-theme="dark"] .mw-toolbar .input{background:#fff;color:#111}
  :root[data-theme="dark"] .mw-toolbar .btn.small{background:color-mix(in oklab, #fff, var(--primary) 4%);color:#111}
  :root[data-theme="dark"] .mw-toolbar .btn.small.active, :root[data-theme="dark"] .mw-toolbar .btn.small:focus{color:#111}
  .mw-highlight{background:color-mix(in oklab, var(--primary) 25%, transparent);padding:0 2px;border-radius:4px}
  :root[data-theme="dark"] .mw-highlight{background:rgba(59,130,246,.35)}
  @media (max-width:800px){ .mw-toolbar .input{flex:1 1 220px} }
    .mw-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
    @media (max-width:1100px){.mw-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media (max-width:700px){.mw-grid{grid-template-columns:1fr;}}
    .mw-card{padding:12px}
    .mw-title{font-size:1.05rem;margin:0 0 4px 0;line-height:1.35}
  .mw-title a{color:var(--primary);text-decoration:none}
  .mw-title a:hover{text-decoration:underline}
    .mw-meta{font-size:.85rem;color:var(--muted);display:flex;gap:6px;flex-wrap:wrap}
  .mw-tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  /* Reason + multi-list badges */
  .mw-badges{display:flex;gap:4px;flex-wrap:wrap;margin:4px 0 2px}
  .mw-badge{display:inline-flex;align-items:center;font-size:.65rem;font-weight:600;letter-spacing:.3px;padding:4px 8px;border-radius:999px;line-height:1;background:color-mix(in oklab,var(--surface-2),var(--primary) 14%);color:color-mix(in oklab,var(--primary-700,#1d4ed8),black 10%);border:1px solid color-mix(in oklab,var(--primary) 55%,var(--border));position:relative}
  .mw-badge[data-type="reason"]{background:linear-gradient(135deg,var(--primary) 0%,var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab,var(--primary-600),white 10%)}
  .mw-badge[data-type="multi"]{background:color-mix(in oklab,var(--warning,#fbbf24),white 8%);color:#92400e;border-color:color-mix(in oklab,#f59e0b,#78350f 40%)}
  :root[data-theme="dark"] .mw-badge{background:color-mix(in oklab,var(--primary-900,#1e3a8a),black 8%);color:#e2e8f0;border-color:color-mix(in oklab,var(--primary-500,#3b82f6),#1e293b 30%)}
  :root[data-theme="dark"] .mw-badge[data-type="reason"]{background:linear-gradient(135deg,var(--primary-400,#60a5fa) 0%,var(--primary-700,#1d4ed8) 100%);color:#fff}
  :root[data-theme="dark"] .mw-badge[data-type="multi"]{background:color-mix(in oklab,#92400e,#fbbf24 25%);color:#fff;border-color:#fbbf24}
    .mw-spark{width:100%;height:54px}
    .mw-aside{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px}
    @media (max-width:900px){.mw-aside{grid-template-columns:repeat(2,minmax(0,1fr));}}
    .mw-leader{padding:12px}
    .mw-leader h3{margin:0 0 6px 0;font-size:1rem;color:var(--secondary)}
    .mw-leader ol{margin:0;padding-left:1.1rem;display:grid;gap:.35rem}
    .mw-leader a{color:var(--link);text-decoration:none}
    .mw-leader a:hover{text-decoration:underline}
    .mw-chiprow{display:flex;gap:6px;flex-wrap:wrap}
    /* Compact toolbar wrapping */
    .mw-toolbar{gap:8px}
    .mw-toolbar .input{min-width:160px}
    @media (max-width:800px){ .mw-toolbar .input{flex:1 1 220px} }
    .mw-modal[hidden]{display:none!important}
    .mw-modal{position:fixed;inset:0;display:grid;place-items:center;z-index:2000}
    .mw-modal .backdrop{position:absolute;inset:0;background:rgba(2,6,23,.55)}
    .mw-dialog{position:relative;background:var(--surface);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow-md);width:min(96vw,1100px);height:min(92vh,760px);display:flex;flex-direction:column;overflow:hidden}
    .mw-dialog .head{display:flex;align-items:center;justify-content:space-between;padding:.65rem 1rem;border-bottom:1px solid var(--border);background:var(--surface-2)}
    .mw-dialog .body{flex:1;overflow:auto;padding:10px}
    /* Daily sections */
    .mw-sec-title{margin:10px 0 8px;color:var(--secondary);font-weight:600}
    .mw-sec-sep{margin:16px 0;border:none;border-top:1px dashed var(--border)}
  </style>
  <!-- Styles: Cascading category filter (三级联动) -->
  <style>
    /* 样式定义：三级联动标签筛选 */
    .mw-cascader { margin-top: 10px; padding: 10px; }
    .mw-cascader { position: relative; }
    .mw-cas-section { margin: 6px 0 8px; }
    .mw-cas-row { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .mw-cas-top { display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; margin: 6px 0; }
    .mw-cas-title { font-weight:600; color: var(--secondary); margin: 4px 0; font-size: .95rem; }
    .mw-cas-sub { margin: 4px 0 0 0; padding-left: 4px; border-left: 2px solid var(--border); }
    .mw-cas-hidden { display:none; }
    /* 一级/二级按钮沿用现有圆角按钮风格 */
    .mw-cas-row .btn, .mw-cas-top .btn { height: 34px; padding: 0 12px; border-radius: 999px; font-size: .9rem; }
    .mw-cas-row .btn.primary { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.28)); color: color-mix(in oklab, var(--primary), black 10%); border-color: color-mix(in oklab, var(--primary), var(--border) 50%); }
    /* 三级任务：复用现有 .tag 标签风格，附加选中高亮 */
    .mw-task { cursor: pointer; user-select: none; }
    .mw-task.active { background: color-mix(in oklab, var(--primary) 18%, white); color: color-mix(in oklab, var(--primary), black 20%); border-color: color-mix(in oklab, var(--primary), var(--border) 40%); }
    :root[data-theme="dark"] .mw-task.active { background: rgba(59,130,246,0.22); color: #e5e7eb; border-color: rgba(59,130,246,0.42); }
    /* 命中卡片高亮（可选，卡片同时被筛选显示） */
    .mw-card.mw-hit { border-color: color-mix(in oklab, var(--primary) 38%, var(--border)); box-shadow: 0 6px 18px rgba(59,130,246,0.18); }
    .mw-cas-tools { display:flex; gap:6px; align-items:center; margin-top: 6px; }

    /* 下拉面板（多列级联选择） */
  .mw-cas-dd { position: absolute; top: 42px; left: 0; z-index: 50; background: var(--surface); border: 1px solid color-mix(in oklab, var(--border), var(--primary) 15%); border-radius: 14px; box-shadow: 0 16px 40px rgba(2,6,23,.18); width: min(92vw, 920px); overflow:hidden }
    .mw-cas-dd .dd-body { display: grid; grid-template-columns: 1.05fr 1.25fr 1.6fr; gap: 0; min-height: 260px; max-height: 62vh; overflow: hidden; }
    .mw-cas-dd .col { border-right: 1px solid var(--border); padding: 10px; overflow: auto; background: color-mix(in oklab, var(--surface), white 2%); }
    .mw-cas-dd .col:nth-child(2){ background: color-mix(in oklab, var(--surface), var(--primary) 3%); }
    .mw-cas-dd .col:last-child { border-right: none; background: color-mix(in oklab, var(--surface), var(--primary) 6%); }
    .mw-cas-dd .dd-foot { display:flex; justify-content: flex-end; gap:10px; padding: 10px; border-top: 1px solid var(--border); background: var(--surface-2); }
    .mw-cas-dd.mw-single-col { width: min(92vw, 340px); }
    .mw-cas-dd.mw-single-col .dd-body { grid-template-columns: 1fr; }
    .mw-list { display:grid; gap:6px; }
    .mw-item { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; cursor:pointer; position:relative; transition: background .15s ease, transform .08s ease; }
    .mw-item::before{content:""; position:absolute; left:4px; top:8px; bottom:8px; width:3px; border-radius:3px; background:transparent}
    .mw-item:hover { background: color-mix(in oklab, var(--surface-2), var(--primary) 10%); }
    .mw-item.active { background: color-mix(in oklab, var(--primary) 14%, white); box-shadow: var(--shadow-sm); }
    .mw-item.active::before{ background: color-mix(in oklab, var(--primary), white 10%); }
    :root[data-theme="dark"] .mw-item.active { background: rgba(59,130,246,0.2); }
    .mw-check { width: 18px; height: 18px; border: 1.5px solid color-mix(in oklab, var(--border), var(--primary) 20%); border-radius: 6px; display:inline-grid; place-items:center; background: var(--surface); color: #fff; font-size:14px; line-height:1; }
    .mw-check[data-on="1"] { border-color: color-mix(in oklab, var(--primary), var(--border) 10%); background: color-mix(in oklab, var(--primary) 28%, white); }
    .mw-muted { color: var(--muted); font-size: .9rem; padding: 10px; }
    /* Mobile cascader - staged navigation */
    @media (max-width: 800px){ 
      .mw-cas-dd .dd-body { grid-template-columns: 1fr; position: relative; overflow: hidden; } 
      .mw-cas-dd { left: 0; width: 100%; max-width: 100vw; } 
      .mw-item{padding:12px 12px; font-size: 16px; -webkit-tap-highlight-color: transparent; }
      .mw-cas-dd .col { border-right: none; position: absolute; width: 100%; height: 100%; transition: transform 0.3s ease; }
      .mw-cas-dd .col.stage-0 { transform: translateX(0); }
      .mw-cas-dd .col.stage-1 { transform: translateX(100%); }
      .mw-cas-dd .col.stage-2 { transform: translateX(200%); }
      .mw-cas-dd .col.stage-active { transform: translateX(0) !important; }
      .mw-cas-dd .col.stage-hidden { transform: translateX(-100%) !important; }
      .mw-mobile-nav { display: flex; align-items: center; padding: 8px 10px; border-bottom: 1px solid var(--border); background: var(--surface-2); }
      .mw-mobile-back { background: none; border: none; color: var(--primary); font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
      .mw-mobile-title { flex: 1; font-weight: 600; color: var(--secondary); text-align: center; font-size: 14px; }
    }
  </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to main content</a>
  <header>
    <nav class="navbar container">
      <a href="../../index.html" class="brand" aria-label="Home">
        <img src="../../assets/logo.svg" alt="Fan Wan logo" class="brand-logo" width="28" height="28" />
        <span class="logo"><span class="i18n l-zh">首页</span><span class="i18n l-en">Home</span><span class="i18n l-es">Inicio</span></span>
      </a>
      <ul class="nav-links">
        <li><a href="../../index.html"><span class="icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M3 12l9-9 9 9"/><path d="M9 21V9h6v12"/></svg></span> <span class="i18n l-zh">首页</span><span class="i18n l-en">Home</span><span class="i18n l-es">Inicio</span></a></li>
        <li><a href="../../about.html"><span class="i18n l-zh">关于我</span><span class="i18n l-en">About</span><span class="i18n l-es">Acerca de</span></a></li>
        <li><a href="../../publications.html"><span class="i18n l-zh">学术出版物</span><span class="i18n l-en">Research</span><span class="i18n l-es">Investigación</span></a></li>
        <li><a href="../../blog.html"><span class="i18n l-zh">博客</span><span class="i18n l-en">Blog</span><span class="i18n l-es">Blog</span></a></li>
        <li><a href="../../ai-lab.html"><span class="i18n l-zh">AI Studio</span><span class="i18n l-en">AI Studio</span><span class="i18n l-es">Taller de IA</span></a></li>
        <li><a href="../../contact.html"><span class="i18n l-zh">联系</span><span class="i18n l-en">Contact</span><span class="i18n l-es">Contacto</span></a></li>
      </ul>
      <div class="nav-actions">
        <div class="lang-switcher">
          <button id="lang-button" class="btn outline icon-btn" aria-haspopup="listbox" aria-expanded="false">
            <svg class="icon icon-globe" viewBox="0 0 24 24" aria-hidden="true"><g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"/><path d="M3 12h18M12 3a15 15 0 0 1 0 18M12 3a15 15 0 0 0 0 18"/></g></svg>
            <span class="label"></span>
          </button>
          <ul id="lang-menu" class="lang-menu" role="listbox" aria-label="Language" hidden>
            <li role="option" data-lang="en">English</li>
            <li role="option" data-lang="zh">中文</li>
            <li role="option" data-lang="es">Español</li>
          </ul>
          <select id="lang-select" hidden>
            <option value="en">English</option>
            <option value="zh">中文</option>
            <option value="es">Español</option>
          </select>
        </div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme" title="Toggle theme">
          <svg class="icon icon-bulb" viewBox="0 0 24 24" aria-hidden="true">
            <g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 18h6"/>
              <path d="M10 22h4"/>
              <path d="M8.5 15.5c-.9-1-1.5-2.3-1.5-3.8a5 5 0 1 1 10 0c0 1.5-.6 2.8-1.5 3.8-.6.7-1.1 1.4-1.3 2.2H9.8c-.2-.8-.7-1.5-1.3-2.2z"/>
              <path d="M12 2v2"/>
              <path d="M4 10h2"/>
              <path d="M18 10h2"/>
              <path d="M5.5 5.5l1.4 1.4"/>
              <path d="M18.5 5.5l-1.4 1.4"/>
            </g>
          </svg>
          <svg class="icon icon-moon" viewBox="0 0 24 24" aria-hidden="true"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <svg class="icon icon-system" viewBox="0 0 24 24" aria-hidden="true"><g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="12" rx="2" ry="2"/><path d="M8 20h8M12 16v4"/></g></svg>
        </button>
        <div class="hamburger" id="hamburger">
          <span></span><span></span><span></span>
        </div>
      </div>
    </nav>
  </header>

  <main id="main">
    <section class="page-hero section">
      <div class="bg-shapes">
        <span class="shape shape1"></span>
        <span class="shape shape2"></span>
        <span class="shape shape3"></span>
        <span class="shape shape4"></span>
      </div>
      <div class="container">
        <h1 data-i18n="modelwatch_title">模型追踪器</h1>
        <p class="subtitle" data-i18n="modelwatch_desc">跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情</p>
      </div>
    </section>

    <section class="section">
      <div class="container mw-wrap">
        <section id="mw-weekly-summary" hidden aria-live="polite">
          <h3>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v4H3z"/><path d="M8 7v14"/><path d="M16 7v14"/><path d="M3 11h18"/><path d="M3 17h18"/></svg>
            <span class="i18n l-zh">每周摘要</span><span class="i18n l-en">Weekly Summary</span><span class="i18n l-es">Resumen semanal</span>
          </h3>
          <div class="mw-summary-tabs" role="tablist" aria-label="Weekly summary language">
            <button data-lang="zh" class="active" role="tab" aria-selected="true">中文</button>
            <button data-lang="en" role="tab" aria-selected="false">EN</button>
            <button data-lang="es" role="tab" aria-selected="false">ES</button>
          </div>
          <p class="mw-summary-text"></p>
          <div class="mw-task-dist" aria-label="Task distribution"></div>
          <p class="mw-empty" hidden></p>
        </section>
        <div class="card mw-card mw-toolbar" role="toolbar" aria-label="Filters">
          <div class="mw-modes" id="mw-modes">
            <button class="btn primary" data-mode="daily" data-i18n="mw_mode_daily">今日灵感</button>
            <button class="btn outline" data-mode="gh" data-i18n="mw_mode_gh_top">工程热榜</button>
            <button class="btn outline" data-mode="hf" data-i18n="mw_mode_hf_top">模型实验场</button>
          </div>
          <div class="mw-cas-inline" style="position:relative;display:flex;align-items:center;gap:12px">
            <button class="btn outline small" id="mw-cas-trigger" data-mode-label="model"><span class="i18n l-zh">按类别查看模型</span><span class="i18n l-en">Browse by Category</span><span class="i18n l-es">Ver por categoría</span></button>
            <!-- 下拉面板：三级级联（单选/单选/多选） -->
            <div class="mw-cas-dd" id="mw-cas-dd" hidden>
              <div class="dd-body">
                <div class="col" id="mw-cas-c1"><div class="mw-muted">—</div></div>
                <div class="col" id="mw-cas-c2"><div class="mw-muted">—</div></div>
                <div class="col" id="mw-cas-c3"><div class="mw-muted">—</div></div>
              </div>
              <div class="dd-foot">
                <button class="btn outline small" id="mw-cas-close"><span class="i18n l-zh">完成</span><span class="i18n l-en">Done</span><span class="i18n l-es">Listo</span></button>
              </div>
            </div>
          </div>
          <div id="mw-datewrap" style="display:flex;align-items:center" hidden>
            <button id="mw-prev" class="btn outline small" title="Prev day" aria-label="Previous day">
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
            <input type="date" id="mw-date" class="input" style="height:36px;padding:6px 8px" />
            <button id="mw-next" class="btn outline small" title="Next day" aria-label="Next day">
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
          </div>
          <select id="mw-sort" class="input">
            <option value="score" data-i18n="mw_sort_score">综合分</option>
            <option value="delta7" data-i18n="mw_sort_delta7">7日增量</option>
            <option value="stars" data-i18n="mw_sort_stars">Stars</option>
            <option value="downloads" data-i18n="mw_sort_downloads">Downloads</option>
            <option value="stars7" data-i18n="mw_sort_stars7">Stars 7日</option>
            <option value="forks7" data-i18n="mw_sort_forks7">Forks 7日</option>
            <option value="downloads7" data-i18n="mw_sort_downloads7">下载 7日</option>
            <option value="likes7" data-i18n="mw_sort_likes7">Likes 7日</option>
          </select>
          <input id="mw-q" class="input" placeholder="搜索标题/摘要/来源…" data-i18n-placeholder="search_placeholder" />
          <button class="btn outline small" id="mw-cas-clear"><span class="i18n l-zh">清空筛选</span><span class="i18n l-en">Clear</span><span class="i18n l-es">Limpiar</span></button>
        </div>

        <div style="margin:12px 0 6px 0" class="muted" id="mw-sub">—</div>

        <!-- 分类级联已集成在工具栏中 -->

        <div class="mw-grid" id="mw-grid"></div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container site-footer-center">
      <p>© <span id="year"></span> Fan Wan</p>
    </div>
  </footer>

  <div class="mw-modal" id="mw-modal" hidden>
    <div class="backdrop" onclick="document.getElementById('mw-modal').hidden=true"></div>
    <div class="mw-dialog">
      <div class="head">
        <strong id="mw-modal-title">—</strong>
        <button class="modal-close" onclick="document.getElementById('mw-modal').hidden=true">✕</button>
      </div>
      <div class="body" id="mw-modal-body"></div>
    </div>
  </div>

  <script>
  (function(){
    const modesEl = document.getElementById('mw-modes');
    const sortEl = document.getElementById('mw-sort');
    const qEl = document.getElementById('mw-q');
  // (gridEl/subEl not needed inside cascader context for dropdown operations)
  const dateWrap = document.getElementById('mw-datewrap');
  const dateInput = document.getElementById('mw-date');
  const prevBtn = document.getElementById('mw-prev');
  const nextBtn = document.getElementById('mw-next');
    const $ = (id)=>document.getElementById(id);

    let MODE = 'daily';
    const SCHEMA_VERSION = 1; // Sync with backend schema.js
    let items = [];
    let catsLoaded = false;
  // no dedicated model picker
    let query = '';
  let availableDates = [];
  let selectedDate = '';
    // Global aggregation cache for Daily across all dates
    let itemsAll = [];
    let allLoaded = false;
    let globalActive = false;

    function isGlobalActive(){ return globalActive; }
    function setGlobalActive(on){
      globalActive = !!on;
      try{
        dateWrap.hidden = globalActive || (MODE !== 'daily');
        subEl.hidden = globalActive;
      }catch{}
    }

    // Fallback canonical categories and labels (used if categories.json not found)
    let CANON = {
      capabilities: ['chat','multimodal','retrieval','code','speech','video','vision','planning','safety','compression','distillation'],
      scenes: ['devex','education','research','search','content','productization','robotics'],
      lifecycle: ['data','training','evaluation','deployment','inference','monitoring']
    };
    let TAG_LABELS = {
      zh: { chat:'对话', multimodal:'多模态', retrieval:'检索', code:'代码', speech:'语音', video:'视频', vision:'视觉', planning:'规划', safety:'安全', compression:'压缩', distillation:'蒸馏', devex:'DevEx', education:'教育', research:'科研', search:'搜索', content:'内容生成', productization:'产品化', robotics:'机器人', data:'数据', training:'训练', evaluation:'评测', deployment:'部署', inference:'推理', monitoring:'监控' },
      en: { chat:'Chat', multimodal:'Multimodal', retrieval:'Retrieval', code:'Code', speech:'Speech', video:'Video', vision:'Vision', planning:'Planning', safety:'Safety', compression:'Compression', distillation:'Distillation', devex:'DevEx', education:'Education', research:'Research', search:'Search', content:'Content Gen', productization:'Productization', robotics:'Robotics', data:'Data', training:'Training', evaluation:'Evaluation', deployment:'Deployment', inference:'Inference', monitoring:'Monitoring' },
      es: { chat:'Conversación', multimodal:'Multimodal', retrieval:'Recuperación', code:'Código', speech:'Voz', video:'Vídeo', vision:'Visión', planning:'Planificación', safety:'Seguridad', compression:'Compresión', distillation:'Destilación', devex:'DevEx', education:'Educación', research:'Investigación', search:'Búsqueda', content:'Generación de contenido', productization:'Productización', robotics:'Robótica', data:'Datos', training:'Entrenamiento', evaluation:'Evaluación', deployment:'Despliegue', inference:'Inferencia', monitoring:'Monitorización' }
    };

    // Build reverse map from any label to canonical key (kept for deriving categories)
    let LABEL_TO_KEY = {};
    (function rebuildLabelIndex(){
      const m = {};
      for(const lang of Object.keys(TAG_LABELS)){
        const dict = TAG_LABELS[lang]||{};
        for(const k of Object.keys(dict)) m[dict[k]] = k;
      }
      for(const group of Object.values(CANON)) for(const k of group) m[k] = k;
      LABEL_TO_KEY = m;
    })();

    const getLang = ()=> (localStorage.getItem('lang')||document.documentElement.lang||'zh');
    // Safe language resolver (fallback zh)
    window.getLangSafe = function getLangSafe(){
      try{
        if(typeof getLang === 'function'){ const v = getLang(); if(v) return v; }
        // Try reading from html[data-lang] or documentElement lang
        const el = document.documentElement;
        const attr = el.getAttribute('data-lang') || el.lang || 'zh';
        return ['zh','en','es'].includes(attr)? attr : 'zh';
      }catch{ return 'zh'; }
    }
    const tagLabel = (key)=> TAG_LABELS[getLangSafe()]?.[key] || key;
    const toKey = (s)=> LABEL_TO_KEY[String(s||'').trim()] || null;
  function string(s){ return String(s); }

    function t(key, fallback){ try { const lang = localStorage.getItem('lang')||document.documentElement.lang||'zh'; const tx=(window.translations?.[lang]?.[key]); return tx||fallback||key; } catch { return fallback||key; } }

    function esc(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');}
    // ================= Weekly Summary Loader =================
    (function initWeeklySummary(){
      const el = document.getElementById('mw-weekly-summary');
      if(!el) return;
      const summaryP = el.querySelector('.mw-summary-text');
      const distBox = el.querySelector('.mw-task-dist');
      const emptyP = el.querySelector('.mw-empty');
      const tabs = el.querySelectorAll('.mw-summary-tabs button');
      let summaryData = null;
      let currentLang = getLangSafe();
      function applyLangButtons(){
        tabs.forEach(btn=>{
          const L = btn.getAttribute('data-lang');
            if(L === currentLang){ btn.classList.add('active'); btn.setAttribute('aria-selected','true'); }
            else { btn.classList.remove('active'); btn.setAttribute('aria-selected','false'); }
        });
      }
      function render(){
        if(!summaryData){ el.hidden=true; return; }
        const sec = summaryData.sections?.overview || {};
        const txt = sec[currentLang] || sec[getLangSafe()] || sec.en || sec.zh || '';
        summaryP.textContent = txt;
        emptyP.hidden = !!txt;
        if(!txt){ emptyP.textContent = currentLang==='zh'? '暂无摘要': (currentLang==='es'? 'Sin resumen disponible' : 'No summary available'); }
        const dist = (summaryData.meta?.task_distribution||[]).slice(0,14);
        distBox.innerHTML = dist.map(d=>`<span class="mw-task-pill" title="${d.task}"><span>${d.task}</span><strong>${d.count}</strong></span>`).join('');
        el.hidden = false;
      }
      async function fetchSummary(){
        const paths=[
          '../../data/ai/modelswatch/weekly_summaries.json',
          '/data/ai/modelswatch/weekly_summaries.json',
          '../data/ai/modelswatch/weekly_summaries.json',
          './data/ai/modelswatch/weekly_summaries.json'
        ];
        for(const p of paths){
          try{ const r = await fetch(p,{cache:'no-store'}); if(r.ok){ summaryData = await r.json(); break; } }catch{}
        }
        if(summaryData){ render(); }
      }
      tabs.forEach(btn=> btn.addEventListener('click',()=>{ const L=btn.getAttribute('data-lang'); if(L){ currentLang=L; applyLangButtons(); render(); }}));
      const obs = new MutationObserver(()=>{ const L=document.documentElement.getAttribute('lang')||'zh'; if(L!==currentLang){ currentLang=L; applyLangButtons(); render(); } });
      obs.observe(document.documentElement,{ attributes:true, attributeFilter:['lang'] });
      fetchSummary(); applyLangButtons();
    })();
    function normalizeStats(it){ if(!it||!it.stats) return it; const s=it.stats; if(s.hf_downloads_7d && !s.downloads_total) s.downloads_total = s.hf_downloads_7d; if(s.hf_likes && !s.likes_total) s.likes_total = s.hf_likes; return it; }
    function normalizeArray(arr){ return (arr||[]).map(normalizeStats); }
    function rel(iso){ try{ const d=new Date(iso); const s=(Date.now()-d)/1000; if(s<60) return 'just now'; if(s<3600) return Math.floor(s/60)+'m'; if(s<86400) return Math.floor(s/3600)+'h'; return Math.floor(s/86400)+'d'; }catch{return ''} }

    // Compute a robust updated_at string (ISO) using meta.updated_at, max item.updated_at, or a date hint
    function toIso(x){
      try{ const t = new Date(x); if(!isNaN(t)) return t.toISOString(); }catch{}
      return '';
    }
    function computeUpdatedAt(metaUpdatedAt, arr, dateHint){
      const cands = [];
      const mIso = toIso(metaUpdatedAt); if(mIso) cands.push(mIso);
      if(Array.isArray(arr)){
        for(const it of arr){
          const u = it?.updated_at || it?.stats?.updated_at;
          const iso = toIso(u); if(iso) cands.push(iso);
        }
      }
      if(!cands.length && dateHint){
        // fallback to the hint date at noon UTC to avoid TZ-aliasing to previous day
        const iso = toIso(`${dateHint}T12:00:00Z`);
        if(iso) cands.push(iso);
      }
      if(!cands.length) return new Date().toISOString();
      // pick the latest
      return cands.reduce((a,b)=> a>b?a:b);
    }

    // No top chips anymore

    function sparkline(ts=[], vals=[], color){
      // Lightweight inline SVG sparkline (last 30 pts or fewer)
      const N = Math.min(vals.length, 30);
      const sliceVals = vals.slice(-N);
      const sliceTs = ts.slice(-N);
      if (!sliceVals.length) return '';
      const W=280, H=54, L=0, R=0, T=6, B=12; const iw=W-L-R, ih=H-T-B;
      const minX = sliceTs[0], maxX = sliceTs[sliceTs.length-1];
      const minY = Math.min(...sliceVals, 0), maxY = Math.max(...sliceVals);
      const xPos = (t)=> L + ( (t-minX)/Math.max(1,(maxX-minX)) )*iw;
      const yPos = (v)=> T + ih - ( (v-minY)/Math.max(1,(maxY-minY)) )*ih;
      let d='';
      for(let i=0;i<sliceVals.length;i++){
        const x=xPos(sliceTs[i]); const y=yPos(sliceVals[i]); d+= (i?` L ${x},${y}`:`M ${x},${y}`);
      }
      const stroke=color||'#0ea5e9';
      return `<svg class="mw-spark" viewBox="0 0 ${W} ${H}" width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <defs>
          <linearGradient id="sg" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="${stroke}"/>
            <stop offset="100%" stop-color="${stroke}" stop-opacity="0.25"/>
          </linearGradient>
        </defs>
        <path d="${d}" fill="none" stroke="url(#sg)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }

    // Simple keyword mapping to canonical categories (multilingual hints)
    const KEYWORDS = {
      chat: [/\bchat\b/i, /对话/, /assistant/i],
      multimodal: [/multimodal/i, /多模态/],
      retrieval: [/retriev/i, /RAG/i, /检索/],
      code: [/\bcode\b/i, /编程/, /coder/i],
      speech: [/speech/i, /audio/i, /语音/],
      video: [/video/i, /视频/],
      vision: [/vision/i, /图像/, /视觉/],
      planning: [/plan/i, /规划/],
      safety: [/safety/i, /安全/],
      compression: [/compress/i, /压缩/],
      distillation: [/distill/i, /蒸馏/],
      devex: [/devex/i, /developer/i],
      education: [/educat/i, /教育/],
      research: [/research/i, /科研/],
      search: [/search/i, /搜索/],
      content: [/content/i, /生成/],
      productization: [/product/i, /产品化/],
      robotics: [/robot/i, /机器人/],
      data: [/data/i, /数据/],
      training: [/train/i, /训练/],
      evaluation: [/eval/i, /评测/],
      deployment: [/deploy/i, /部署/],
      inference: [/infer/i, /推理/],
      monitoring: [/monitor/i, /监控/]
    };

    function deriveCategories(it){
      const text = `${it.name||''} ${(it.summary||'')} ${(it.tags||[]).join(' ')}`;
      const cats = { capabilities: new Set(), scenes: new Set(), lifecycle: new Set() };
      const push = (k)=>{
        if (CANON.capabilities.includes(k)) cats.capabilities.add(k);
        else if (CANON.scenes.includes(k)) cats.scenes.add(k);
        else if (CANON.lifecycle.includes(k)) cats.lifecycle.add(k);
      };
      for(const [k, regs] of Object.entries(KEYWORDS)){
        if (regs.some(r=> r.test(text))) push(k);
      }
      return {
        capabilities: [...cats.capabilities],
        scenes: [...cats.scenes],
        lifecycle: [...cats.lifecycle]
      };
    }

    // Task label mapping from ai_categories.json
    let TASK_KEY_BY_LABEL = {};
    let TASK_LABELS_BY_KEY = {};
  let TASK_MATCHERS = [];
    function buildTaskMapFromCategories(tree){
      const keyByLabel = {};
      const labelsByKey = {};
      (tree||[]).forEach(c=> (c.subcategories||[]).forEach(s=> (s.tasks||[]).forEach(t=>{
        labelsByKey[t.key] = { zh: t.zh||'', en: t.en||'', es: t.es||'' };
        ['zh','en','es'].forEach(L=>{ const v = (t[L]||'').trim().toLowerCase(); if(v) keyByLabel[v] = t.key; });
      })));
      TASK_KEY_BY_LABEL = keyByLabel; TASK_LABELS_BY_KEY = labelsByKey;
    }
    function escRe(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
    function buildTaskMatchers(){
      // Core synonyms/abbreviations per task key
      const SYN = {
        // Vision
        image_classification: ['image classification','图像分类','clasificación de imágenes','imagenet','classifier'],
        object_detection: ['object detection','目标检测','detección de objetos','yolo','rcnn','retinanet'],
        semantic_segmentation: ['semantic segmentation','语义分割','segmentación semántica','segmentation model','deeplab'],
        instance_segmentation: ['instance segmentation','实例分割','segmentación de instancias','mask r-cnn','mask-rcnn','maskrcnn'],
        panoptic_segmentation: ['panoptic segmentation','全景分割','segmentación panóptica','panoptic'],
        text_to_image: ['text-to-image','文本生成图像','文生图','texto a imagen','stable diffusion','sdxl','diffusion','gan'],
        text_to_video: ['text-to-video','文本生成视频','文生视频','texto a video','video diffusion','sora'],
        nerf: ['nerf','神经辐射场','campos radiantes','instant-ngp'],
        super_resolution: ['super-resolution','超分辨','超分','superres','sr','esrgan','real-esrgan'],
        denoising: ['denoising','去噪','reducción de ruido','denoise','denoiser'],
        restoration: ['restoration','复原','restauración','deblurring','inpainting'],
  vqa: ['vqa','视觉问答','visual question answering'],
        visual_grounding: ['visual grounding','视觉定位','grounding','phrase grounding'],
  // keep lightweight but avoid overly generic matches by relying on boundaries later
  lightweight_visual_model: ['lightweight','轻量化','mobile','edge','tiny','nano'],
        // LLM & NLP
        llm_pretraining: ['pre-training','pretraining','预训练','preentrenamiento','language modeling'],
        instruction_tuning: ['instruction tuning','指令微调','指令学习','sft','supervised fine-tuning'],
        rlhf: ['rlhf','human feedback','人类反馈','pbrl','rm','reward model'],
        rag: ['rag','retrieval-augmented generation','检索增强生成','generación aumentada por recuperación'],
        code_generation: ['code generation','代码生成','generación de código','coder','codegen'],
  structured_reasoning: ['structured reasoning','结构化推理','razonamiento estructurado','tree of thoughts','graph of thoughts','chain of thought','cot'],
  tool_use: ['tool use','工具调用','uso de herramientas','agents','function calling','tool calling'],
  // drop overly generic 'adapter' to avoid false positives
  lora_adapter: ['lora','peft','low-rank','adalora','qlora'],
        multilingual_processing: ['multilingual','多语言','multilingüe','cross-lingual'],
        low_resource_language: ['low-resource language','低资源语言','pocos recursos','low resource'],
        knowledge_editing: ['knowledge editing','知识编辑','edición de conocimiento','knowledge injection'],
        nlp_data_synthesis: ['data synthesis','数据合成','síntesis de datos','synthetic data'],
        nlp_data_distillation: ['data distillation','数据蒸馏','destilación de datos'],
        dialogue_system_optimization: ['dialogue system','对话系统','sistema de diálogo','chatbot'],
        nlp_bias_mitigation: ['bias','偏见','sesgo','mitigation','harmful'],
        // Multimodal & Speech
        image_text_alignment: ['clip','图文对齐','image-text alignment'],
        multimodal_understanding_generation: ['multimodal','多模态','multimodal generation','gpt-4v','flamingo','llava'],
        asr: ['asr','automatic speech recognition','语音识别'],
        tts: ['tts','text-to-speech','语音合成'],
        slu: ['slu','spoken language understanding','语音理解'],
        speaker_separation: ['speaker separation','说话人分离','separación de hablantes'],
        noise_separation: ['noise separation','噪声分离','ruido ambiental'],
        full_duplex_dialogue: ['full-duplex','全双工'],
        avsr: ['avsr','audio-visual speech recognition','视听语音识别'],
        multimodal_dialogue_system: ['multimodal dialogue','多模态对话'],
        lightweight_multimodal_model: ['lightweight multimodal','多模态轻量化','edge multimodal'],
        // Graph / Recommendation / Retrieval
        gnn: ['gnn','graph neural network','图神经网络'],
        kg_construction: ['knowledge graph construction','知识图谱构建','construcción de grafos de conocimiento','kg build'],
        kg_reasoning: ['kg reasoning','知识图谱推理','razonamiento kg'],
  general_recommendation: ['recommendation system','推荐系统','recommender','reco'],
        vertical_recommendation: ['vertical recommendation','垂直推荐'],
        vector_retrieval: ['vector retrieval','向量检索','similarity search','faiss','ann','hnsw'],
        vector_db_optimization: ['vector database','向量数据库','milvus','weaviate','qdrant','chroma'],
        metric_learning: ['metric learning','度量学习'],
        contrastive_learning: ['contrastive learning','对比学习','cl'],
        ltr: ['learning to rank','学习排序','ltr'],
        neural_retrieval: ['neural retrieval','神经检索'],
        graph_augmented_reco: ['graph-augmented recommendation','图增强推荐'],
        // Optimization / System / Security
        model_compression: ['model compression','模型压缩','pruning','sparsity'],
  model_quantization: ['quantization','量化','int8','int4','quantize','gptq','awq'],
        model_distillation: ['distillation','蒸馏','knowledge distillation'],
        compilation_optimization: ['compilation optimization','编译优化','tvm','xla','triton'],
        inference_acceleration: ['inference acceleration','推理加速','vllm','tensorrt-llm','onnxruntime','openvino'],
        federated_learning: ['federated learning','联邦学习','fl'],
        privacy_computing: ['differential privacy','同态加密','差分隐私','homomorphic encryption','dp'],
  adversarial_attack: ['adversarial attack','对抗攻击'],
  adversarial_defense: ['adversarial defense','对抗防御'],
  red_teaming: ['red team','红队测试','red teaming'],
        content_moderation: ['content moderation','内容审查','moderación de contenidos'],
        auto_evaluation_models: ['evaluation model','评测模型','judge','arena','autoeval'],
        edge_hw_sw_co_design: ['edge ai hardware','硬件 软件 协同','硬软协同','co-design'],
        xai: ['xai','explainable ai','可解释'],
        ai_ethics_risk_assessment: ['ethics risk','伦理 风险','cumplimiento ético'],
        training_data_anonymization: ['anonymization','脱敏','anonimización'],
        training_data_copyright: ['copyright','版权'],
        model_monitoring: ['model monitoring','模型监控','monitorización de modelos'],
        model_iterative_update: ['iterative update','迭代 更新'],
        // Emerging / Temporal
        fluid_simulation: ['fluid simulation','流体模拟'],
        material_design: ['material design','材料 设计'],
        drug_molecule_prediction: ['drug','molecule','药物 分子'],
        robotic_vision: ['robotic vision','机器人 视觉'],
        robot_motion_planning: ['motion planning','运动 规划'],
        robot_environment_interaction: ['environment interaction','环境 交互'],
        molecular_generation: ['molecular generation','分子 生成'],
        bioinformatics_analysis: ['bioinformatics','生物 信息'],
        time_series_forecasting: ['time series forecasting','时间 序列 预测','ts forecasting'],
        time_series_anomaly_detection: ['time series anomaly detection','序列 异常 检测','ts anomaly'],
        radar_understanding: ['radar','雷达'],
        lidar_understanding: ['lidar','激光雷达','lidar data'],
        low_resource_medical_ai: ['low-resource medical ai','低资源 医疗'],
        low_resource_voice_assistant: ['low-resource voice assistant','低资源 语音 助手'],
        ar_vr_interaction: ['ar/vr','xr','虚拟 现实','增强 现实'],
        multimodal_temporal_fusion: ['multimodal temporal fusion','多模态 时序 融合'],
        robot_dialogue_logic: ['robot dialogue','机器人 对话']
      };
      const matchers = [];
      const ALLOWED_SHORTS = new Set(['ASR','TTS','SLU','RAG','GNN','XAI','NERF','AVSR','LTR','LORA']);
      for(const key of Object.keys(TASK_LABELS_BY_KEY)){
        const labels = TASK_LABELS_BY_KEY[key]||{};
        const pats = [];
        // exact label boundaries to avoid substring matches
        for(const L of ['zh','en','es']){
          const v = (labels[L]||'').trim();
          if(v){
            // Use word boundaries for latin labels, raw for CJK
            const isLatin = /[A-Za-z]/.test(v);
            pats.push(new RegExp(isLatin?`\\b${escRe(v.toLowerCase())}\\b`:escRe(v.toLowerCase()), 'i'));
          }
        }
        // curated aliases with safeguards: skip very short generic tokens (<4) unless whitelisted
        for(const aliasRaw of (SYN[key]||[])){
          const alias = aliasRaw.toLowerCase();
          const isLatin = /[A-Za-z]/.test(alias);
          const isShort = alias.replace(/[^A-Za-z0-9]/g,'').length < 4;
          if(isShort && !ALLOWED_SHORTS.has(alias.toUpperCase())) continue;
          const re = new RegExp(isLatin?`\\b${escRe(alias)}\\b`:escRe(alias), 'i');
          pats.push(re);
        }
        // common abbreviations (safe, with boundaries)
        const caps = key.toUpperCase();
        if(ALLOWED_SHORTS.has(caps)) pats.push(new RegExp(`\\b${escRe(caps)}\\b`, 'i'));
        matchers.push({ key, pats });
      }
      TASK_MATCHERS = matchers;
    }
    async function loadTaskMap(){
      const paths = [
        '../../data/ai/ai_categories.json',
        '/data/ai/ai_categories.json',
        '../data/ai/ai_categories.json',
        './data/ai/ai_categories.json'
      ];
      for(const p of paths){
        try{
          const res = await fetch(p,{cache:'no-store'}); if(!res.ok) continue;
          const txt = await res.text();
          try{
            const cj = JSON.parse(txt);
            if(cj?.categories){ buildTaskMapFromCategories(cj.categories); buildTaskMatchers(); return true; }
          }catch{}
        }catch{}
      }
      // even without file, keep empty matchers
      TASK_MATCHERS = [];
      return false;
    }
    function stdTagLabel(x){
      const raw = String(x||'');
      const rawTrim = raw.trim();
      const L = getLang();
      // If tag is exactly a known task key, map directly
      if(TASK_LABELS_BY_KEY[rawTrim]) return TASK_LABELS_BY_KEY[rawTrim][L] || rawTrim;
      const low = rawTrim.toLowerCase();
      const key = TASK_KEY_BY_LABEL[low]; if(!key) return raw;
      return TASK_LABELS_BY_KEY[key]?.[L] || raw;
    }

    function textOf(it){
      const fields = [it.id,it.name,it.url,it.summary,it.summary_en,it.summary_zh,it.summary_es].concat(it.tags||[]);
      return (fields.filter(Boolean).join(' ').toLowerCase());
    }
    function computeMatchedTaskKeys(it){
      const txt = textOf(it);
      const keys = new Set();
      // leverage existing tags mapping if any
      (it.tags||[]).forEach(tag=>{
        const low = String(tag||'').trim().toLowerCase();
        const k = TASK_KEY_BY_LABEL[low]; if(k) keys.add(k);
      });
      // run matchers
      for(const m of TASK_MATCHERS){
        if(m.pats.some(p=> p.test(txt))){ keys.add(m.key); }
      }
      return [...keys];
    }
    function labelsFromTaskKeys(keys){
      const L = getLang();
      const out = [];
      const seen = new Set();
      for(const k of keys){ const v = TASK_LABELS_BY_KEY[k]?.[L]; if(v && !seen.has(v)){ seen.add(v); out.push(v); } }
      return out.slice(0,6);
    }

    function pickSummary(it){
      const lang = getLang();
      if(lang==='zh') return it.summary_zh || it.summary || it.description || '';
      if(lang==='es') return it.summary_es || it.summary || it.description || '';
      // default en
      return it.summary_en || it.summary || it.description || '';
    }

    function card(it){
      const src = it.source==='github'?'GitHub':'HF';
      const tags = (it.tags||[]).slice(0,6).map(x=>`<span class="tag">${esc(x)}</span>`).join(' ');
      const metrics = (function(){
        const p=[];
        if(it.source==='github') p.push(`★ ${(it.stats?.stars||0)}`); else p.push(`⬇︎ ${(it.stats?.downloads_total||0)}`);
        if(it.stats?.forks) p.push(`⑂ ${it.stats.forks}`);
        if(it.stats?.likes_total) p.push(`❤ ${(it.stats?.likes_total)}`);
        if(it.stats?.stars_7d) p.push(`★7d ${it.stats.stars_7d}`);
        if(it.stats?.forks_7d) p.push(`⑂7d ${it.stats.forks_7d}`);
        if(it.stats?.downloads_7d) p.push(`⬇︎7d ${(it.stats?.downloads_7d)}`);
        if(it.stats?.likes_7d) p.push(`❤7d ${(it.stats?.likes_7d)}`);
        if(it.score_model) p.push(`S ${Number(it.score_model).toFixed(2)}`);
        if(it.score_engineering) p.push(`S ${Number(it.score_engineering).toFixed(2)}`);
        return p.join(' · ');
      })();
      const last = it.updated_at?` · ${rel(it.updated_at)}`:'';
      const color = getComputedStyle(document.documentElement).getPropertyValue('--secondary')||'#0ea5e9';
      const tms = (it.timeline?.t||[]).map(x=>Date.parse(x));
      const starSeries = it.timeline?.stars || [];
      const dlSeries = it.timeline?.downloads || [];
      const series = (src==='GitHub') ? starSeries : dlSeries;
      const sgv = sparkline(tms, series, color);
      const url = it.url || (src==='GitHub'?`https://github.com/${esc(it.id)}`:`https://huggingface.co/${esc(it.id)}`);
      const sum = pickSummary(it);
      // Reason badge translation
      function reasonLabel(key){
        if(!key) return '';
        const lang = getLangSafe();
        const mapKey = 'mw_reason_'+key.replace(/[^a-z0-9_]/g,'');
        return (window.translations?.[lang]?.[mapKey]) || key;
      }
      // Task badge translation with fallbacks (meta -> translations -> en -> zh -> key)
      function taskLabel(key, lang){
        const meta = (TASK_LABELS_BY_KEY && TASK_LABELS_BY_KEY[key]) || {};
        // Direct meta match for current language
        if(meta[lang]) return meta[lang];
        // Look for explicit translation dictionary entry e.g. mw_task_<key>
        const tKey = 'mw_task_'+key.replace(/[^a-z0-9_]/g,'');
        const trans = window.translations?.[lang]?.[tKey];
        if(trans) return trans;
        // Fall back priority: English meta (if different), then Chinese, then any non-empty, finally raw key
        if(lang !== 'en' && meta.en) return meta.en;
        if(meta.zh) return meta.zh;
        if(meta.es) return meta.es; // last resort other locale
        return meta.en || key;
      }
      const reason = it.reason_label ? `<span class="mw-badge" data-type="reason" title="${esc(it.reason_text||'')}">${esc(reasonLabel(it.reason_label))}</span>` : '';
      // Per-task badges: always show task list if task_keys present. Replace generic Multi badge.
      let multi = '';
      try{
        if(Array.isArray(it.task_keys) && it.task_keys.length){
          const lang = getLangSafe();
          const maxShow = 3;
          const tkAll = it.task_keys;
          const shown = tkAll.slice(0,maxShow);
          const hidden = tkAll.length - shown.length;
          const labelMap = TASK_LABELS_BY_KEY || {};
          multi = shown.map(k=>{
            const txt = taskLabel(k, lang);
            return `<span class=\"mw-badge\" data-type=\"multi\" title=\"${esc(k)}\">${esc(txt)}</span>`;
          }).join('');
          if(hidden>0){
            multi += `<span class=\"mw-badge\" data-type=\"multi\" title=\"${esc(tkAll.join(', '))}\">+${hidden}</span>`;
          }
          if(multi) multi = `<div class=\"mw-badges\">${multi}</div>`;
        }
      }catch{}
      const badges = (reason||multi)? `<div class=\"mw-badges\">${reason}${multi}</div>` : '';
      return `<article class="card mw-card" data-id="${esc(it.id)}">
        <h4 class="mw-title"><a href="${esc(url)}" target="_blank" rel="noopener noreferrer">${esc(it.name||it.id)}</a></h4>
        <div class="mw-meta">${src} · ${metrics}${last}</div>
        ${badges}
        <div class="mw-tags">${tags}</div>
        <div>${sgv}</div>
        ${sum?`<p class=\"muted\" style=\"margin:.5rem 0 0 0; line-height:1.4\">${esc(sum)}</p>`:''}
      </article>`;
    }

    // Build searchable text and score by query tokens
    function buildSearchIndex(it){
      const lang = getLang();
      const summaryLang = lang==='zh'? it.summary_zh : lang==='es'? it.summary_es : it.summary_en;
      const parts = [it.id,it.name,it.source,summaryLang,it.summary,it.summary_en,it.summary_zh,it.summary_es].concat(it.tags||[]);
      return parts.filter(Boolean).join(' ').toLowerCase();
    }
    function scoreItem(it, tokens){
      if(!tokens.length) return 0;
      let score = 0;
      const text = buildSearchIndex(it);
      for(const tk of tokens){
        const idx = text.indexOf(tk);
        if(idx>=0){
          // proximity + early boost
          score += 10;
          if(idx<40) score += 4;
          if(/\b/.test(tk)) score += 2;
        }
      }
      // small boost for more matching tags
      const tg = (it.tags||[]).join(' ').toLowerCase();
      for(const tk of tokens){ if(tg.includes(tk)) score+=3; }
      return score;
    }
    function highlightText(html, tokens){
      if(!tokens.length) return html;
      try{
        const escaped = tokens.map(t=> t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'));
        if(!escaped.length) return html;
        const re = new RegExp('('+escaped.join('|')+')','ig');
        return html.replace(re, m=>`<span class="mw-highlight">${m}</span>`);
      }catch{return html;}
    }
    function filterSort(arr){
      // 1) Defensive de-duplication (source + id/url/name as stable key)
      const seen = new Set();
      let out = [];
      for(const it of arr){
        const key = `${it.source||''}::${it.id||it.url||it.name||''}`;
        if(seen.has(key)) continue; seen.add(key); out.push(it);
      }
  // no model-id exact filter (covered by search)
      // search
      const qs = (query||'').trim().toLowerCase();
      if(qs){
        const rawTokens = qs.split(/\s+/).filter(Boolean);
        // allow simple partial tokens by also trying original string
        out = out.filter(it =>{
          const text = buildSearchIndex(it);
          if(text.includes(qs)) return true;
          return rawTokens.every(tk => text.includes(tk));
        });
      }
      // sort
      const key = sortEl.value||'score';
      if(qs){
        const tokens = qs.split(/\s+/).filter(Boolean);
        out.forEach(o=>{ o.__qScore = scoreItem(o, tokens); });
        out.sort((a,b)=> b.__qScore - a.__qScore);
      } else {
        out.sort((a,b)=>{
          if(key==='delta7'){
            const av = (a.stats?.stars_7d ?? a.stats?.downloads_7d ?? 0);
            const bv = (b.stats?.stars_7d ?? b.stats?.downloads_7d ?? 0);
            return bv - av;
          }
          if(key==='stars') return (b.stats?.stars||0) - (a.stats?.stars||0);
          if(key==='downloads') return (b.stats?.downloads_total||0) - (a.stats?.downloads_total||0);
          if(key==='stars7') return (b.stats?.stars_7d||0) - (a.stats?.stars_7d||0);
          if(key==='forks7') return (b.stats?.forks_7d||0) - (a.stats?.forks_7d||0);
          if(key==='downloads7') return (b.stats?.downloads_7d||0) - (a.stats?.downloads_7d||0);
          if(key==='likes7') return (b.stats?.likes_7d||0) - (a.stats?.likes_7d||0);
          return (b.score||b.score_model||b.score_engineering||0) - (a.score||a.score_model||a.score_engineering||0);
        });
      }
      return out;
    }

    function render(){
    let arr = filterSort(items);
    // Engineering category single-select filtering
    if((window.__mw_mode_current||'')==='gh' && selectedEngineeringCategory){
      arr = arr.filter(it=> it.category_key===selectedEngineeringCategory || it.__group===selectedEngineeringCategory);
    }
  const dt = window.__mw_updated_at || '';
      const lang = localStorage.getItem('lang')||document.documentElement.lang||'zh';
      // Removed explicit updated-at display per user request
      let modeLabel = MODE==='daily'? (window.translations?.[lang]?.mw_mode_daily || 'Daily Picks') : MODE==='gh'? (window.translations?.[lang]?.mw_mode_gh_top || 'GitHub Top') : (window.translations?.[lang]?.mw_mode_hf_top || 'HF Top');
      if(isGlobalActive()){
        subEl.hidden = true;
      }else{
        subEl.hidden = false;
        if (lang==='en') subEl.textContent = `${modeLabel} · Items ${arr.length}`;
        else if (lang==='es') subEl.textContent = `${modeLabel} · Elementos ${arr.length}`;
        else subEl.textContent = `${modeLabel} · 共 ${arr.length} 项`;
      }

      // Disable/hide irrelevant sort options per mode (hide by disabling + style)
      const hideMatrix = {
        gh: new Set(['downloads','downloads7','likes7']),
        hf: new Set(['stars','stars7','forks7']),
        daily: new Set(['forks7','downloads','downloads7','likes7','stars7'])
      };
      const hide = hideMatrix[MODE]||new Set();
      for(const opt of sortEl.options){
        const shouldHide = hide.has(opt.value);
        opt.disabled = shouldHide;
        opt.hidden = shouldHide;
      }
      // If current sort now hidden -> fallback to score
      if(sortEl.selectedOptions[0]?.hidden){ sortEl.value='score'; }
      updateClearButtonVisibility();

      // no datalist population

      // Render content
      if (MODE==='daily'){
        if(isGlobalActive()){
          gridEl.classList.add('mw-grid');
          const arrG = filterSort(itemsAll);
          gridEl.innerHTML = arrG.map(card).join('');
        }else{
          // Render two full-width sections: GitHub first, then a divider, then HF
          gridEl.classList.remove('mw-grid');
          const gh = arr.filter(x=>x.source==='github');
          const hf = arr.filter(x=>x.source!=='github');
          const ghTitle = t('mw_section_gh', 'GitHub 开源项目');
          const hfTitle = t('mw_section_hf', 'Hugging Face 开源模型');
          const ghHtml = gh.length? `<div class="mw-sec-title">${esc(ghTitle)} · ${gh.length}</div><div class="mw-grid">${gh.map(card).join('')}</div>` : '';
          const sep = (gh.length && hf.length)? `<hr class="mw-sec-sep"/>` : '';
          const hfHtml = hf.length? `<div class="mw-sec-title">${esc(hfTitle)} · ${hf.length}</div><div class="mw-grid">${hf.map(card).join('')}</div>` : '';
          gridEl.innerHTML = ghHtml + sep + hfHtml;
        }
      }else{
        // Hotlist grouping (engineering or model lab) when hotlist structure present
        const grouping = window.__mw_hot_grouping;
        if(grouping && arr.some(it=>it.__group)){
          gridEl.classList.remove('mw-grid');
          const order = [];
          const bucket = {};
          for(const it of arr){ const g=it.__group||'other'; if(!bucket[g]){ bucket[g]=[]; order.push(g);} bucket[g].push(it); }
          const lang2 = getLangSafe();
          function labelForGroup(k){ return TAG_LABELS?.[lang2]?.[k] || k; }
          const sections = order.map(k=>{
            let list = filterSort(bucket[k]);
            if((window.__mw_mode_current||'')==='gh' && selectedEngineeringCategory && k!==selectedEngineeringCategory){ list = []; }
            return `<details open data-group="${esc(k)}" class="mw-hot-group"><summary style="cursor:pointer;font-weight:600;margin:12px 0 6px;color:var(--secondary)">${esc(labelForGroup(k))} · ${list.length}</summary><div class="mw-grid">${list.map(card).join('')}</div></details>`;
          });
          gridEl.innerHTML = sections.join('');
        }else{
          gridEl.classList.add('mw-grid');
            gridEl.innerHTML = arr.map(card).join('');
        }
      }
    }

    // Extend existing mode switching (modesEl listener defined earlier in file) by observing MODE changes
    const origSetMode = (function(){ return null; })(); // placeholder to avoid ref errors
    // Mutation observer pattern not needed; just patch after initial event binding
    (function hookModeButtons(){
      try{
        const modesEl = document.getElementById('mw-modes');
        if(!modesEl) return;
        modesEl.addEventListener('click', (e)=>{
          const btn = e.target.closest('button[data-mode]'); if(!btn) return;
          const mode = btn.getAttribute('data-mode');
          window.__mw_mode_current = mode; // expose
          try{ setTriggerLabelForMode(mode); }catch{}
        });
        // initial label
        setTriggerLabelForMode(MODE);
      }catch{}
    })();

    async function loadCategories(){
      try{
        const cj = await fetch('../../data/ai/modelswatch/categories.json',{cache:'no-store'}).then(r=>r.json());
        if(cj?.categories) CANON = cj.categories;
        if(cj?.labels) TAG_LABELS = cj.labels;
        rebuildLabelIndex();
        catsLoaded = true;
      }catch{ catsLoaded = false; }
    }

    async function loadDaily(dateStr){
      try{
        if(dateStr){
          // load combined archive for the specified date
          const d = await fetch(`../../data/ai/modelswatch/daily/${dateStr}.json`,{cache:'no-store'}).then(r=>r.json());
          const arr = (d?.items||[]).map(shallowNormalize);
          items = arr;
          window.__mw_updated_at = computeUpdatedAt(d?.updated_at, arr, dateStr);
        }else{
          const [g,h] = await Promise.all([
            fetch('../../data/ai/modelswatch/daily_github.json',{cache:'no-store'}).then(r=>r.json()),
            fetch('../../data/ai/modelswatch/daily_hf.json',{cache:'no-store'}).then(r=>r.json()),
          ]);
          const gi = (g?.items||[]).map(shallowNormalize);
          const hi = (h?.items||[]).map(shallowNormalize);
          // merge + dedupe
          const seen = new Set(); const merged=[];
          for(const it of [...gi, ...hi]){ const k = `${it.source||''}::${it.id||it.url||it.name||''}`; if(seen.has(k)) continue; seen.add(k); merged.push(it); }
          items = merged;
          // choose the newer meta among g/h
          const gIso = toIso(g?.updated_at);
          const hIso = toIso(h?.updated_at);
          const newerMeta = (gIso && hIso) ? (gIso>hIso?gIso:hIso) : (gIso || hIso || '');
          window.__mw_updated_at = computeUpdatedAt(newerMeta, merged);
        }
      }catch{ items=[]; window.__mw_updated_at=''; }
    }

    async function loadTopGH(){
      // Prefer new engineering hotlist
      try{
        const hot = await fetch('../../data/ai/modelswatch/projects_hotlist.json',{cache:'no-store'}).then(r=>r.json());
        if(hot?.by_category){
          if(typeof hot.version==='number' && hot.version!==1){ console.warn('[mw] projects_hotlist version mismatch', hot.version); }
          const out=[]; const multiCount={};
          for(const [cat,list] of Object.entries(hot.by_category)){
            (list||[]).forEach(it=>{ out.push(shallowNormalize({...it,__group:cat,__hot:'projects'})); multiCount[it.id]=(multiCount[it.id]||0)+1; });
          }
          out.forEach(o=>{ if(multiCount[o.id]>1) o.__multi=true; });
          items = out; window.__mw_hot_grouping='projects';
          window.__mw_updated_at = computeUpdatedAt(hot?.updated_at, out);
          return;
        }
      }catch(e){ /* fallback */ }
      try{
        const g = await fetch('../../data/ai/modelswatch/top_github.json',{cache:'no-store'}).then(r=>r.json());
        const arr = (g?.items||[]).map(shallowNormalize);
        items = arr; window.__mw_hot_grouping='';
        window.__mw_updated_at = computeUpdatedAt(g?.updated_at, arr);
      }catch{ items=[]; window.__mw_updated_at=''; window.__mw_hot_grouping=''; }
    }

    async function loadTopHF(){
      // Prefer new models hotlist
      try{
        const hot = await fetch('../../data/ai/modelswatch/models_hotlist.json',{cache:'no-store'}).then(r=>r.json());
        if(hot?.by_category){
          if(typeof hot.version==='number' && hot.version!==1){ console.warn('[mw] models_hotlist version mismatch', hot.version); }
          const out=[]; const multiCount={};
          for(const [task,list] of Object.entries(hot.by_category)){
            (list||[]).forEach(it=>{ out.push(shallowNormalize({...it,__group:task,__hot:'models'})); multiCount[it.id]=(multiCount[it.id]||0)+1; });
          }
          out.forEach(o=>{ if(multiCount[o.id]>1) o.__multi=true; });
          items = out; window.__mw_hot_grouping='models';
          window.__mw_updated_at = computeUpdatedAt(hot?.updated_at, out);
          return;
        }
      }catch(e){ /* fallback */ }
      try{
        const h = await fetch('../../data/ai/modelswatch/top_hf.json',{cache:'no-store'}).then(r=>r.json());
        const arr = (h?.items||[]).map(shallowNormalize);
        items = arr; window.__mw_hot_grouping='';
        window.__mw_updated_at = computeUpdatedAt(h?.updated_at, arr);
      }catch{ items=[]; window.__mw_updated_at=''; window.__mw_hot_grouping=''; }
    }

    async function loadAllDaily(){
      if(allLoaded) return;
      try{
        if(availableDates.length===0){
          try{ availableDates = await fetch('../../data/ai/modelswatch/daily/dates.json',{cache:'no-store'}).then(r=>r.json()); }
          catch{ availableDates = []; }
        }
        const seen = new Set(); const merged = [];
        const chunk = 6;
        for(let i=0;i<availableDates.length;i+=chunk){
          const batch = availableDates.slice(i,i+chunk);
          const res = await Promise.allSettled(batch.map(d=> fetch(`../../data/ai/modelswatch/daily/${d}.json`,{cache:'no-store'}).then(r=>r.json())));
          for(const r of res){
            if(r.status==='fulfilled'){
              const arr = (r.value?.items||[]).map(shallowNormalize);
              for(const it of arr){ const k = `${it.source||''}::${it.id||it.url||it.name||''}`; if(seen.has(k)) continue; seen.add(k); merged.push(it); }
            }
          }
        }
        itemsAll = merged; allLoaded = true;
      }catch{ itemsAll = []; allLoaded = false; }
    }

    function shallowNormalize(it){
      const id = it.id || it.repo_id || it.url || it.name;
      const source = it.source || (id&&id.includes('huggingface.co')?'hf':'github');
      const name = it.name || (id||'').split('/').pop();
      const base = {
        id, source, name,
        url: it.url || it.homepage || it.card_url,
        license: it.license || 'N/A',
        lang: it.lang || it.language || 'N/A',
        // Tags will be derived from authoritative task_keys first, then fuzzy fallback
        tags: [],
        categories: it.categories||{capabilities:[],scenes:[],lifecycle:[]},
        stats: it.stats||{},
        score: it.score||0,
        timeline: it.timeline||{t:[],stars:[],downloads:[]},
        summary: it.summary||'',
        summary_en: it.summary_en||'',
        summary_zh: it.summary_zh||'',
        summary_es: it.summary_es||'',
        updated_at: it.updated_at||new Date().toISOString()
      };
      // Prefer server-provided task_keys to avoid client overlabeling
      try{
        const providedKeys = Array.isArray(it.task_keys)? it.task_keys : [];
        let labels = [];
        if(providedKeys.length){
          labels = labelsFromTaskKeys(providedKeys);
        }
        if(labels.length===0){
          const keys = computeMatchedTaskKeys({ ...it, ...base });
          labels = labelsFromTaskKeys(keys);
        }
        base.tags = labels.length>0 ? labels : (it.tags||[]).map(stdTagLabel);
      }catch{}
      // Keep old deriveCategories if needed (not used for tags)
      if ((!base.categories.capabilities?.length) && (!base.categories.scenes?.length) && (!base.categories.lifecycle?.length)){
        base.categories = deriveCategories(base);
      }
      return base;
    }

    async function init(){
  await loadCategories();
    await loadTaskMap();
      // Load date list for daily archives
      try{ availableDates = await fetch('../../data/ai/modelswatch/daily/dates.json', {cache:'no-store'}).then(r=>r.json()); if(!Array.isArray(availableDates)) availableDates = []; }catch{ availableDates = []; }
      // set bounds for native calendar (if we have dates)
      if(availableDates.length>0){
        dateInput.min = availableDates[availableDates.length-1];
        dateInput.max = availableDates[0];
        dateInput.value = availableDates[0];
        selectedDate = '';
      }
      // show date controls in Daily mode only
      dateWrap.hidden = (MODE !== 'daily');
      await loadDaily(selectedDate);
      render();
      sortEl.onchange = async ()=>{
        if(MODE==='daily'){
          if(!allLoaded) await loadAllDaily();
          setGlobalActive(true);
        }
        render();
      };
      qEl.addEventListener('input', async ()=>{
        query=qEl.value||'';
        if(MODE==='daily'){
          if(!allLoaded) await loadAllDaily();
          setGlobalActive(!!query);
        }
        render();
      });
      // toggle global view when cascader makes a selection or clears
      window.addEventListener('mw-global-toggle', async (e)=>{
        const on = !!(e?.detail?.on);
        if(MODE==='daily'){
          if(on && !allLoaded) await loadAllDaily();
          setGlobalActive(on);
          render();
        }
      });
  window.addEventListener('language-changed', ()=>{ render(); });
      // Mode switching
      modesEl.addEventListener('click', async (e)=>{
        const btn = e.target.closest('button[data-mode]');
        if(!btn) return;
        const mode = btn.getAttribute('data-mode');
        if(!mode || mode===MODE) return;
        MODE = mode;
        window.__mw_mode_current = mode;
        [...modesEl.querySelectorAll('button')].forEach(b=>{
          b.classList.toggle('primary', b===btn);
          b.classList.toggle('outline', b!==btn);
        });
        // Auto default sort per mode
        if(MODE==='gh'){ sortEl.value='score'; }
        else if(MODE==='hf'){ sortEl.value='score'; }
        else { sortEl.value='score'; }
        // Reset engineering selection when leaving gh
        if(MODE!=='gh'){ selectedEngineeringCategory = null; }
        if(MODE==='daily'){
          dateWrap.hidden = false;
          await loadDaily(selectedDate);
        }
        else if(MODE==='gh') await loadTopGH();
        else await loadTopHF();
        if(MODE!=='daily') dateWrap.hidden = true; else setGlobalActive(false);
        try{ setTriggerLabelForMode(MODE); }catch{}
        updateTriggerLabel();
        updateClearButtonVisibility();
        render();
      });

      // date interactions
      dateInput.addEventListener('change', async ()=>{
        const v = dateInput.value;
        selectedDate = (v && availableDates.includes(v)) ? v : '';
        await loadDaily(selectedDate);
        setGlobalActive(false);
        render();
      });
      prevBtn.addEventListener('click', async ()=>{
        if(availableDates.length===0) return;
        let cur = dateInput.value || availableDates[0];
        let idx = availableDates.indexOf(cur);
        if(idx<0) idx = 0;
        if(idx+1 < availableDates.length){
          dateInput.value = availableDates[idx+1];
          selectedDate = dateInput.value;
          await loadDaily(selectedDate);
          setGlobalActive(false);
          render();
        }
      });
      nextBtn.addEventListener('click', async ()=>{
        if(availableDates.length===0) return;
        let cur = dateInput.value || availableDates[0];
        let idx = availableDates.indexOf(cur);
        if(idx>0){
          dateInput.value = availableDates[idx-1];
          selectedDate = dateInput.value;
          await loadDaily(selectedDate);
          setGlobalActive(false);
          render();
        }
      });
    }

    init();
  })();
  </script>

  <!-- Script: Cascading category filter (三级分类筛选) -->
  <script>
    // Card renderer (kept minimal & robust)
    function card(it){
      const url = it.url || it.homepage || it.repo || '#';
      const src = esc(it.source||'');
      const metrics = esc(it.stars?`★${it.stars}`: it.likes?`❤${it.likes}`:'');
      const last = it.updated_at?` · ${esc(it.updated_at.substring(0,10))}`:'';
      const tags = (it.task_keys||it.tags||[]).map(t=>`<span class="tag">${esc(t)}</span>`).join('');
      const sum = it.summary_en || it.summary || '';
      return `<article class="card mw-card" data-id="${esc(it.id)}">\n        <h4 class="mw-title"><a href="${esc(url)}" target="_blank" rel="noopener noreferrer">${esc(it.name||it.id)}</a></h4>\n        <div class="mw-meta">${src} · ${metrics}${last}</div>\n        <div class="mw-tags">${tags}</div>\n        ${sum?`<p class=\\"muted\\" style=\\"margin:.5rem 0 0 0; line-height:1.4\\">${esc(sum)}</p>`:''}\n      </article>`;
    }

    // ===== Cascader (三级分类筛选) =====
    const casWrap = document.querySelector('.mw-cas-inline');
    const clearBtn = document.getElementById('mw-cas-clear');
    const triggerBtn = document.getElementById('mw-cas-trigger');
    let PROJECT_CATEGORIES = [];
    async function ensureProjectCategories(){
      if(PROJECT_CATEGORIES.length) return;
      try{
        const pj = await fetch('../../data/ai/modelswatch/project_categories.json',{cache:'no-store'}).then(r=>r.json());
        PROJECT_CATEGORIES = pj?.categories||[];
      }catch{ PROJECT_CATEGORIES=[]; }
    }
    function setTriggerLabelForMode(mode){
      const lang = getLangSafe();
      if(mode==='gh'){
        // Engineering hotlist
        triggerBtn.dataset.modeLabel='project';
        const zh='按类别查看项目', en='Browse Projects by Category', es='Ver proyectos por categoría';
        triggerBtn.innerHTML = `<span>${lang==='en'?en:lang==='es'?es:zh}</span>`;
      }else if(mode==='hf'){
        triggerBtn.dataset.modeLabel='model';
        const zh='按类别查看模型', en='Browse Models by Category', es='Ver modelos por categoría';
        triggerBtn.innerHTML = `<span>${lang==='en'?en:lang==='es'?es:zh}</span>`;
      }else{
        triggerBtn.dataset.modeLabel='model';
        const zh='按类别查看', en='Browse by Category', es='Ver por categoría';
        triggerBtn.innerHTML = `<span>${lang==='en'?en:lang==='es'?es:zh}</span>`;
      }
    }
    window.addEventListener('language-changed', (e)=>{ try{ setTriggerLabelForMode(window.__mw_mode_current||'daily'); }catch{} });
    const dd = document.getElementById('mw-cas-dd');
    const col1 = document.getElementById('mw-cas-c1');
    const col2 = document.getElementById('mw-cas-c2');
    const col3 = document.getElementById('mw-cas-c3');
    const closeBtn = document.getElementById('mw-cas-close');
  // Global grid/sub header elements (restored after earlier refactor removal)
  const gridEl = document.getElementById('mw-grid');
  const subEl = document.getElementById('mw-sub');
  let mobileStage = 0; let selCat = null, selSub = null; const selectedTasks = new Set();
  // Engineering (GitHub hotlist) single-select category filter state
  let selectedEngineeringCategory = null; // holds category key
  // Initialize immediately with builtin tree so UI renders instantly; remote JSON (if any) will hydrate later.
  let CAT_TREE = null; // will be assigned after BUILTIN_TREE declared
  let CAT_REMOTE_LOADED = false; // whether remote categories replaced builtin
  const labelOf = (obj)=> { if(!obj) return ''; const L = getLangSafe(); return obj[L] || obj.zh || obj.en || obj.es || ''; }

    // Built-in fallback tree (partial) for robust UX if JSON cannot be loaded
  const BUILTIN_TREE = [
      {
        key: 'cv', zh: '计算机视觉', en: 'Computer Vision', es: 'Visión por Computadora',
        subcategories: [
          { key: 'general_visual_understanding', zh:'通用视觉理解', en:'General Visual Understanding', es:'Comprensión Visual General', tasks:[
            { key:'image_classification', zh:'图像分类', en:'Image Classification', es:'Clasificación de Imágenes' },
            { key:'object_detection', zh:'目标检测', en:'Object Detection', es:'Detección de Objetos' },
            { key:'semantic_segmentation', zh:'语义分割', en:'Semantic Segmentation', es:'Segmentación Semántica' },
            { key:'instance_segmentation', zh:'实例分割', en:'Instance Segmentation', es:'Segmentación de Instancias' },
            { key:'panoptic_segmentation', zh:'全景分割', en:'Panoptic Segmentation', es:'Segmentación Panóptica' }
          ]},
          { key:'generative_vision', zh:'生成式视觉', en:'Generative Vision', es:'Visión Generativa', tasks:[
            { key:'text_to_image', zh:'文生图（Diffusion/GAN）', en:'Text-to-Image (Diffusion/GAN)', es:'Texto-a-Imagen (Diffusion/GAN)' },
            { key:'text_to_video', zh:'文生视频', en:'Text-to-Video', es:'Texto-a-Vido' },
            { key:'3d_reconstruction', zh:'三维重建', en:'3D Reconstruction', es:'Reconstrucción 3D' },
            { key:'nerf', zh:'NeRF（神经辐射场）', en:'NeRF (Neural Radiance Fields)', es:'NeRF (Campos Radiantes Neuronales)' }
          ]},
          { key:'visual_quality_enhancement', zh:'视觉质量增强', en:'Visual Quality Enhancement', es:'Mejora de Calidad Visual', tasks:[
            { key:'super_resolution', zh:'图像/视频超分', en:'Image/Video Super-Resolution', es:'Sobreresolución de Imágenes/Videos' },
            { key:'denoising', zh:'图像/视频去噪', en:'Image/Video Denoising', es:'Reducción de Ruido en Imágenes/Videos' },
            { key:'restoration', zh:'图像/视频复原', en:'Image/Video Restoration', es:'Restauración de Imágenes/Videos' }
          ]},
          { key:'vertical_visual_applications', zh:'垂直视觉应用', en:'Vertical Visual Applications', es:'Aplicaciones Visuales Verticals', tasks:[
            { key:'medical_image_processing', zh:'医学影像处理', en:'Medical Image Processing', es:'Procesamiento de Imágenes Médicas' },
            { key:'remote_sensing_image_processing', zh:'遥感/工业影像处理', en:'Remote Sensing/Industrial Image Processing', es:'Procesamiento de Imágenes de Teledetección/Industriales' }
          ]},
          { key:'multimodal_visual_interaction', zh:'多模态视觉交互', en:'Multimodal Visual Interaction', es:'Interacción Visual Multimodal', tasks:[
            { key:'vqa', zh:'视觉问答（VQA）', en:'Visual Question Answering (VQA)', es:'Pregunta-Respuesta Visual (VQA)' },
            { key:'visual_grounding', zh:'视觉定位（Grounding）', en:'Visual Grounding', es:'Localización Visual (Grounding)' }
          ]},
          { key:'edge_visual_optimization', zh:'端侧视觉优化', en:'Edge-Side Visual Optimization', es:'Optimización Visual para Dispositivos Periféricos', tasks:[
            { key:'lightweight_visual_model', zh:'边缘端视觉模型轻量化', en:'Lightweight Visual Model for Edge Devices', es:'Modelo Visual Ligero para Dispositivos de Borde' }
          ]}
        ]
      },
      {
        key:'llm_nlp', zh:'大语言模型与自然语言处理', en:'Large Language Models & Natural Language Processing', es:'Modelos de Lenguaje Grande y Procesamiento de Lenguaje Natural',
        subcategories:[
          { key:'llm_foundation_training', zh:'LLM基础训练', en:'LLM Foundation Training', es:'Entrenamiento Básico de LLM', tasks:[
            { key:'llm_pretraining', zh:'语言建模（LLM预训练）', en:'Language Modeling (LLM Pre-training)', es:'Modelado de Lenguaje (Preentrenamiento de LLM)' }
          ]},
          { key:'llm_training_optimization', zh:'LLM训练优化', en:'LLM Training Optimization', es:'Optimización de Entrenamiento de LLM', tasks:[
            { key:'instruction_tuning', zh:'指令学习（Instruction Tuning）', en:'Instruction Tuning', es:'Ajuste por Instrucciones (Instruction Tuning)' }
          ]},
          { key:'llm_alignment_optimization', zh:'LLM对齐优化', en:'LLM Alignment Optimization', es:'Optimización de Alineación de LLM', tasks:[
            { key:'rlhf', zh:'RLHF（基于人类反馈的强化学习）', en:'RLHF (Reinforcement Learning from Human Feedback)', es:'RLHF (Aprendizaje por Refuerzo a partir de Retroalimentación Humana)' }
          ]},
          { key:'llm_capability_enhancement', zh:'LLM能力增强', en:'LLM Capability Enhancement', es:'Mejora de Capacidades de LLM', tasks:[
            { key:'rag', zh:'RAG（检索增强生成）', en:'RAG (Retrieval-Augmented Generation)', es:'RAG (Generación Mejorada por Recuperación)' }
          ]},
          { key:'llm_application_deployment', zh:'LLM应用落地', en:'LLM Application Deployment', es:'Despliegue de Aplicaciones de LLM', tasks:[
            { key:'code_generation', zh:'代码生成', en:'Code Generation', es:'Generación de Código' }
          ]},
          { key:'llm_complex_reasoning', zh:'LLM复杂推理', en:'LLM Complex Reasoning', es:'Razonamiento Complejo de LLM', tasks:[
            { key:'structured_reasoning', zh:'结构化推理', en:'Structured Reasoning', es:'Razonamiento Estructurado' },
            { key:'tool_use', zh:'工具调用（Tool Use）', en:'Tool Use', es:'Uso de Herramientas (Tool Use)' }
          ]},
          { key:'llm_efficient_fine_tuning', zh:'LLM高效微调', en:'LLM Efficient Fine-Tuning', es:'Ajuste Fino Eficiente de LLM', tasks:[
            { key:'lora_adapter', zh:'LoRA/Adapter（参数高效微调）', en:'LoRA/Adapter (Parameter-Efficient Fine-Tuning)', es:'LoRA/Adapter (Ajuste Fino Eficiente en Parámetros)' }
          ]},
          { key:'llm_cross_lingual', zh:'LLM跨语言能力', en:'LLM Cross-Lingual Capability', es:'Capacidad Multilingüe de LLM', tasks:[
            { key:'multilingual_processing', zh:'多语言处理', en:'Multilingual Processing', es:'Procesamiento Multilingüe' },
            { key:'low_resource_language', zh:'低资源语言处理', en:'Low-Resource Language Processing', es:'Procesamiento de Idiomas con Poca Recursos' }
          ]},
          { key:'llm_knowledge_management', zh:'LLM知识管理', en:'LLM Knowledge Management', es:'Gestión de Conocimiento de LLM', tasks:[
            { key:'knowledge_editing', zh:'知识编辑/注入', en:'Knowledge Editing/Injection', es:'Edición/Inyección de Conocimiento' }
          ]},
          { key:'llm_data_support', zh:'LLM数据支撑', en:'LLM Data Support', es:'Soporte de Datos para LLM', tasks:[
            { key:'nlp_data_synthesis', zh:'NLP数据合成', en:'NLP Data Synthesis', es:'Síntesis de Datos en PLN' },
            { key:'nlp_data_distillation', zh:'NLP数据蒸馏', en:'NLP Data Distillation', es:'Destilación de Datos en PLN' }
          ]},
          { key:'nlp_hci', zh:'NLP人机交互', en:'NLP Human-Computer Interaction', es:'Interacción Humano-Computadora en PLN', tasks:[
            { key:'dialogue_system_optimization', zh:'对话系统优化', en:'Dialogue System Optimization', es:'Optimización de Sistema de Diálogo' }
          ]},
          { key:'nlp_ethical_compliance', zh:'NLP伦理合规', en:'NLP Ethical Compliance', es:'Cumplimiento Ético en PLN', tasks:[
            { key:'nlp_bias_mitigation', zh:'NLP偏见检测与消除', en:'NLP Bias Detection and Mitigation', es:'Detección y Mitigación de Prejuicios en PLN' }
          ]}
        ]
      },
      {
        key:'multimodal_speech', zh:'多模态与语音', en:'Multimodal & Speech', es:'Multimodal y Voz',
        subcategories:[
          { key:'cross_modal_alignment', zh:'跨模态基础对齐', en:'Cross-Modal Foundation Alignment', es:'Alineación Básica Intermodal', tasks:[
            { key:'image_text_alignment', zh:'图文对齐（CLIP系）', en:'Image-Text Alignment (CLIP Series)', es:'Alineación Imagen-Texto (Serie CLIP)' }
          ]},
          { key:'multimodal_large_models', zh:'多模态大模型', en:'Multimodal Large Models', es:'Modelos Grandes Multimodales', tasks:[
            { key:'multimodal_understanding_generation', zh:'多模态理解与生成（GPT-4V/Flamingo）', en:'Multimodal Understanding & Generation (GPT-4V/Flamingo)', es:'Comprensión y Generación Multimodales (GPT-4V/Flamingo)' }
          ]},
          { key:'fundamental_speech_tech', zh:'语音基础技术', en:'Fundamental Speech Technologies', es:'Tecnologías Básicas de Voz', tasks:[
            { key:'asr', zh:'ASR（语音识别）', en:'ASR (Automatic Speech Recognition)', es:'ASR (Reconocimiento Automático de Voz)' },
            { key:'tts', zh:'TTS（语音合成）', en:'TTS (Text-to-Speech)', es:'TTS (Texto-a-Voz)' }
          ]},
          { key:'advanced_speech_understanding', zh:'语音深度理解', en:'Advanced Speech Understanding', es:'Comprensión Avanzada de Voz', tasks:[
            { key:'slu', zh:'SLU（语音理解）', en:'SLU (Spoken Language Understanding)', es:'SLU (Comprensión de Lenguaje Hablado)' }
          ]},
          { key:'speech_separation_recognition', zh:'语音分离与识别', en:'Speech Separation & Recognition', es:'Separación y Reconocimiento de Voz', tasks:[
            { key:'speaker_separation', zh:'说话人分离', en:'Speaker Separation', es:'Separación de Habitantes' },
            { key:'noise_separation', zh:'场景噪声分离', en:'Environmental Noise Separation', es:'Separación de Ruido Ambiental' }
          ]}
        ]
      }
    ];

    const CAT_CACHE_KEY = 'mw_cat_tree_v1';
    const CAT_CACHE_TTL = 1000 * 60 * 60 * 24 * 7; // 7 days
    function tryLoadCachedCats(){
      try{
        const raw = localStorage.getItem(CAT_CACHE_KEY); if(!raw) return false;
        const obj = JSON.parse(raw);
        if(!obj || !obj.ts || !Array.isArray(obj.data)) return false;
        if(Date.now() - obj.ts > CAT_CACHE_TTL) return false;
        CAT_TREE = obj.data; CAT_REMOTE_LOADED = true; console.log('[Cascader] loaded categories from cache'); return true;
      }catch{ return false; }
    }
    function cacheCats(){
      try{ if(CAT_REMOTE_LOADED && Array.isArray(CAT_TREE)){ localStorage.setItem(CAT_CACHE_KEY, JSON.stringify({ts:Date.now(), data:CAT_TREE})); } }catch{}
    }
    async function loadAiCategories(){
      if(CAT_REMOTE_LOADED) return true;
      const paths = [
        '../../data/ai/ai_categories.json', '/data/ai/ai_categories.json', '../data/ai/ai_categories.json', './data/ai/ai_categories.json'
      ];
      const controllers = [];
      const fetches = paths.map(p=>{
        const c = new AbortController(); controllers.push(c);
        const to = setTimeout(()=> c.abort(), 2500); // abort slow path
        return fetch(p,{cache:'no-store', signal:c.signal}).then(r=>{ clearTimeout(to); if(!r.ok) throw new Error('bad '+p); return r.text(); })
          .then(txt=>{ try{ const cj = JSON.parse(txt); if(cj?.categories) return cj.categories; throw 0; }catch{ throw new Error('parse '+p); }});
      });
      let cats = null;
      try{ cats = await Promise.any(fetches); }catch{ cats = null; }
      controllers.forEach(c=>{ try{ c.abort(); }catch{} });
      if(Array.isArray(cats) && cats.length){
        CAT_TREE = cats; CAT_REMOTE_LOADED = true; cacheCats(); console.log('[Cascader] remote categories loaded');
        return true;
      }
      // if remote fails leave existing (builtin or cache) in place
      return false;
    }
    // Assign initial tree (builtin) before any rendering
    CAT_TREE = BUILTIN_TREE;
    // Attempt cache then background refresh (non-blocking)
    if(!tryLoadCachedCats()){
      // fire and forget
      loadAiCategories().then(changed=>{ if(changed && dd && !dd.hidden){ renderCol1(); renderCol2(); renderCol3(); } });
    }

    // Built-in labels for the six top-level categories (fallback labels when JSON fails or before load)
    const TOP_CATS = [
      { key: 'cv', zh: '计算机视觉', en: 'Computer Vision', es: 'Visión por Computadora' },
  { key: 'llm_nlp', zh: '大语言模型与自然语言处理', en: 'Large Language Models & Natural Language Processing', es: 'Modelos de Lenguaje Grande y Procesamiento de Lenguaje Natural' },
      { key: 'multimodal_speech', zh: '多模态与语音', en: 'Multimodal & Speech', es: 'Multimodal y Voz' },
  { key: 'graph_reco_retrieval', zh: '图网络、推荐与检索', en: 'Graph, Recommendation & Retrieval', es: 'Grafos, Recomendación y Recuperación' },
  { key: 'optimization_system_security', zh: '优化、系统与安全', en: 'Optimization, System & Security', es: 'Optimización, Sistemas y Seguridad' },
  { key: 'emerging_temporal', zh: '新兴交叉与时序模态', en: 'Emerging Interdisciplinary & Temporal Modalities', es: 'Interdisciplinario Emergente y Modalidades Temporales' }
    ];
    console.log('[Cascader] TOP_CATS initialized', { count: TOP_CATS.length, sample: TOP_CATS.map(c=>c.key) });

    // Safety: if cascader container missing, skip all without affecting rest of page
    if(!casWrap){ console.debug('[Cascader] no container, aborting cascader init'); }

    function findCatByKey(key){
      if(!CAT_TREE) return null;
      return CAT_TREE.find(c=> c.key===key) || null;
    }

    // Mobile navigation helpers
    function isMobile(){ return window.innerWidth <= 800; }
    function setMobileStage(stage){ 
      mobileStage = stage; 
      if(!isMobile()) return;
      [col1, col2, col3].forEach((col, i) => {
        col.className = col.className.replace(/stage-\w+/g, '');
        if(i === stage) col.classList.add('stage-active');
        else if(i < stage) col.classList.add('stage-hidden'); 
        else col.classList.add(`stage-${i}`);
      });
    }
    function updateMobileVisibility(){
      if(!isMobile()){
        // desktop ensure all visible
        [col1,col2,col3].forEach(c=>{ if(c) c.style.display='block'; });
        return;
      }
      if(mobileStage===0){
        if(col1) col1.style.display='block';
        if(col2) col2.style.display='none';
        if(col3) col3.style.display='none';
      }else if(mobileStage===1){
        if(col1) col1.style.display='none';
        if(col2) col2.style.display='block';
        if(col3) col3.style.display='none';
      }else{
        if(col1) col1.style.display='none';
        if(col2) col2.style.display='none';
        if(col3) col3.style.display='block';
      }
    }
    function addMobileNavHeader(col, title, canGoBack = false){
      if(!isMobile()) return;
      const nav = document.createElement('div'); nav.className = 'mw-mobile-nav';
      if(canGoBack){
        const back = document.createElement('button'); 
        back.className = 'mw-mobile-back';
        back.innerHTML = '← Back';
        back.addEventListener('click', ()=> setMobileStage(mobileStage - 1));
        nav.appendChild(back);
      }
      const titleEl = document.createElement('div'); titleEl.className = 'mw-mobile-title'; titleEl.textContent = title;
      nav.appendChild(titleEl);
      col.prepend(nav);
    }

    // Dropdown cascader rendering
    function renderCol1(){
      if(!casWrap||!col1) return;
      console.log('[Cascader] renderCol1 start', { selCat, hasTree: !!CAT_TREE, topCount: Array.isArray(TOP_CATS)?TOP_CATS.length:'n/a' });
      const list = document.createElement('div'); list.className = 'mw-list';
      if(!Array.isArray(TOP_CATS) || TOP_CATS.length===0){
        list.innerHTML = '<div class="mw-muted">(no categories)</div>';
        console.warn('[Cascader] TOP_CATS empty at renderCol1');
      }
      TOP_CATS.forEach(meta=>{
        console.log('[Cascader] renderCol1 item', meta.key, labelOf(meta));
        const item = document.createElement('div'); item.className = 'mw-item' + (selCat===meta.key?' active':''); item.dataset.key = meta.key;
        let lbl = labelOf(meta);
        if(!lbl){
          console.warn('[Cascader] empty label for top category key=', meta.key, meta);
          lbl = meta.key || '(?)';
        }
        item.textContent = lbl;
        item.addEventListener('click', (e)=>{
          e.stopPropagation();
          selCat = meta.key; selSub = null; // reset second level when switching
          // fast background load (already triggered on init); if still not remote loaded, try again but don't block UI
          if(!CAT_REMOTE_LOADED){ loadAiCategories().then(changed=>{ if(changed){ if(selCat===meta.key) { renderCol2(); renderCol3(); }}}); }
          renderCol1(); renderCol2(); renderCol3();
          if(isMobile()) setMobileStage(1);
        });
        list.appendChild(item);
      });
      col1.innerHTML = ''; 
      if(isMobile()) addMobileNavHeader(col1, 'Categories');
      col1.appendChild(list);
      updateMobileVisibility();
    }

    function renderCol2(){
      if(!casWrap||!col2) return;
      col2.innerHTML = '';
      const cat = selCat && findCatByKey(selCat);
      if(!cat){ col2.innerHTML = '<div class="mw-muted">—</div>'; return; }
      if(isMobile()) addMobileNavHeader(col2, labelOf(cat), true);
      const list = document.createElement('div'); list.className = 'mw-list';
      (cat.subcategories||[]).forEach(sub=>{
        const item = document.createElement('div'); item.className = 'mw-item' + (selSub===sub.key?' active':''); item.dataset.key = sub.key;
        item.textContent = labelOf(sub);
        item.addEventListener('click', (e)=>{ 
          e.stopPropagation();
          selSub = sub.key; renderCol2(); renderCol3(); 
          if(isMobile()) setMobileStage(2);
        });
        list.appendChild(item);
      });
      col2.appendChild(list);
      updateMobileVisibility();
    }

    function renderCol3(){
      if(!casWrap||!col3) return;
      col3.innerHTML = '';
      const cat = selCat && findCatByKey(selCat);
      const sub = (cat?.subcategories||[]).find(s=> s.key===selSub);
      if(!sub){ col3.innerHTML = '<div class="mw-muted">—</div>'; return; }
      if(isMobile()) addMobileNavHeader(col3, labelOf(sub), true);
      const list = document.createElement('div'); list.className = 'mw-list';
      (sub.tasks||[]).forEach(tsk=>{
        const item = document.createElement('div'); item.className = 'mw-item' + (selectedTasks.has(tsk.key)?' active':'');
        const box = document.createElement('span'); box.className = 'mw-check'; box.dataset.on = selectedTasks.has(tsk.key)?'1':'0'; box.innerHTML = selectedTasks.has(tsk.key)?'✓':'';
        const label = document.createElement('span'); label.textContent = labelOf(tsk);
        item.appendChild(box); item.appendChild(label);
        const toggle = (e)=>{
          e?.stopPropagation();
          if(selectedTasks.has(tsk.key)) selectedTasks.delete(tsk.key); else selectedTasks.add(tsk.key);
          applyFilter(); renderCol3(); updateTriggerLabel();
          // Notify main script to toggle global mode in Daily
          const on = selectedTasks.size>0; window.dispatchEvent(new CustomEvent('mw-global-toggle',{detail:{on}}));
          // Ensure clear button visibility updates immediately after task selection
          try{ updateClearButtonVisibility(); }catch{}
        };
        item.addEventListener('click', toggle);
        list.appendChild(item);
      });
      col3.appendChild(list);
      updateMobileVisibility();
    }

    function openDropdown(){
      if(!dd) return;
      dd.hidden = false;
      mobileStage = 0;
      // When in engineering mode, render a simplified single-column category list
      if((window.__mw_mode_current||'')==='gh'){
        renderEngineeringCategories();
        dd.classList.add('mw-single-col');
        if(col2) col2.style.display='none';
        if(col3) col3.style.display='none';
      } else {
        dd.classList.remove('mw-single-col');
        if(col2) col2.style.display='';
        if(col3) col3.style.display='';
        renderCol1(); renderCol2(); renderCol3();
        if(isMobile()) { setMobileStage(0); updateMobileVisibility(); }
      }
      setTimeout(()=> document.addEventListener('click', outsideClose),0);
    }
    function closeDropdown(){ if(!dd) return; dd.hidden = true; document.removeEventListener('click', outsideClose); }
    function outsideClose(e){ if(!dd) return; if(!dd.contains(e.target) && e.target!==triggerBtn && !triggerBtn?.contains(e.target)) closeDropdown(); }
    if(triggerBtn){ triggerBtn.addEventListener('click', e=>{ e.stopPropagation(); if(dd?.hidden) openDropdown(); else closeDropdown(); }); }
    if(closeBtn){ closeBtn.addEventListener('click', ()=> closeDropdown()); }

    function normalize(str){ return String(str||'').trim().toLowerCase(); }

    function itemMatchesTasks(cardEl){
      if(selectedTasks.size===0) return true;
      // Collect visible labels (from tags inside the card)
      const tagEls = cardEl.querySelectorAll('.mw-tags .tag');
      const labels = new Set();
      tagEls.forEach(t=> labels.add(normalize(t.textContent)));
      const title = normalize(cardEl.querySelector('.mw-title')?.textContent||'');
      const sum = normalize(cardEl.querySelector('.muted')?.textContent||'');
      // Build label set of selected tasks (current language first, but fallback all languages)
      const want = new Set();
      // Map selected keys to labels from CAT_TREE
      const map = new Map(); // key -> {zh,en,es}
      CAT_TREE?.forEach(c=> (c.subcategories||[]).forEach(s=> (s.tasks||[]).forEach(t=>{ map.set(t.key, t); })));
      selectedTasks.forEach(k=>{ const t = map.get(k)||{}; ['zh','en','es'].forEach(L=>{ if(t[L]) want.add(normalize(t[L])); }); });
      // OR logic: match if any label present as exact tag OR appears in title/summary
      for(const w of want){ if(labels.has(w) || title.includes(w) || sum.includes(w)) return true; }
      return false;
    }

    function applyFilter(){
      // Show/hide cards and add highlight class
      const cards = gridEl.querySelectorAll('.mw-card');
      let shown = 0;
      cards.forEach(card=>{
        const hit = itemMatchesTasks(card);
        card.style.display = hit? '' : 'none';
        card.classList.toggle('mw-hit', hit && selectedTasks.size>0);
        if(hit) shown++;
      });
      // Update subtle count suffix
      try{
        const L = getLang();
        const suffix = (selectedTasks.size>0) ? (L==='en'? ` · Filtered ${shown}` : L==='es'? ` · Filtrado ${shown}` : ` · 已筛选 ${shown} 项`) : '';
        // Always compute fresh base from current text (strip previous suffix if exists)
        const current = subEl.textContent || '';
        const base = current.replace(/\s·\s(已筛选|Filtered|Filtrado).*$/, '');
        subEl.setAttribute('data-base', base);
        subEl.textContent = base + suffix;
      }catch{}
    }

    // Re-apply filter whenever grid re-renders (mode switch, search, date change)
    const mo = new MutationObserver(()=>{ applyFilter(); });
    mo.observe(gridEl, { childList: true, subtree: false });

    // Clear selection
    clearBtn.addEventListener('click', ()=>{
      // Reset cascader tasks, model picker, search, and sort
      selectedTasks.clear();
      selectedEngineeringCategory = null;
      updateTriggerLabel();
      const qEl = document.getElementById('mw-q'); if(qEl){ qEl.value=''; }
      const sortEl = document.getElementById('mw-sort'); if(sortEl){ sortEl.value='score'; }
      applyFilter();
      // trigger top-level re-render to apply search/sort reset
      try{ const evt = new Event('input'); qEl?.dispatchEvent(evt); }catch{}
      // Notify main to exit global mode
      try{ window.dispatchEvent(new CustomEvent('mw-global-toggle',{detail:{on:false}})); }catch{}
      updateClearButtonVisibility();
    });


    function updateTriggerLabel(){
      if(!triggerBtn) return;
      const mode = window.__mw_mode_current||'daily';
      if(mode==='gh'){
        // Engineering: show selected category label if any
        const lang = getLangSafe();
        let baseZh='按类别查看项目', baseEn='Browse Projects by Category', baseEs='Ver proyectos por categoría';
        const catObj = PROJECT_CATEGORIES.find(c=>c.key===selectedEngineeringCategory);
        const catLabel = catObj ? (catObj[lang]||catObj.zh||catObj.en||catObj.es||catObj.key) : '';
        const finalZh = catLabel? `${baseZh}：${catLabel}`: baseZh;
        const finalEn = catLabel? `${baseEn}: ${catLabel}`: baseEn;
        const finalEs = catLabel? `${baseEs}: ${catLabel}`: baseEs;
        triggerBtn.innerHTML = `<span>${lang==='en'?finalEn: lang==='es'?finalEs: finalZh}</span>`;
        triggerBtn.classList.toggle('active', !!catLabel);
      } else {
        const cnt = selectedTasks.size;
        const zh = triggerBtn.querySelector('.i18n.l-zh'); if(zh) zh.textContent = `按类别查看模型${cnt>0?` (${cnt})`:''}`;
        const en = triggerBtn.querySelector('.i18n.l-en'); if(en) en.textContent = `Browse by Category${cnt>0?` (${cnt})`:''}`;
        const es = triggerBtn.querySelector('.i18n.l-es'); if(es) es.textContent = `Ver por categoría${cnt>0?` (${cnt})`:''}`;
        triggerBtn.classList.toggle('active', cnt>0);
      }
    }

    function updateClearButtonVisibility(){
      if(!clearBtn) return;
      const mode = window.__mw_mode_current||'daily';
      // Show clear button only when a category (engineering) or task selection (model lab) is active
      let filtered = false;
      if(mode==='gh') {
        filtered = !!selectedEngineeringCategory;
      } else if(mode==='hf') {
        filtered = selectedTasks.size>0; // tasks chosen in model lab
      } else {
        filtered = selectedTasks.size>0; // daily global multi-view also can use selection to expand view
      }
      clearBtn.style.display = filtered ? '' : 'none';
    }

    function renderEngineeringCategories(){
      // Reuse col1 only; hide col2/col3
      if(!dd) return;
      ensureProjectCategories().then(()=>{
        if(col1){
          const list = document.createElement('div'); list.className='mw-list';
          PROJECT_CATEGORIES.forEach(cat=>{
            const item = document.createElement('div'); item.className='mw-item'+(selectedEngineeringCategory===cat.key?' active':'');
            item.textContent = labelOf(cat) || cat.key;
            item.dataset.key = cat.key;
            item.addEventListener('click', e=>{
              e.stopPropagation();
              if(selectedEngineeringCategory===cat.key){ selectedEngineeringCategory = null; } else { selectedEngineeringCategory = cat.key; }
              updateTriggerLabel();
              closeDropdown();
              // Trigger re-render main list (filter applied in render)
              try{ window.dispatchEvent(new Event('mw-engineering-filter')); }catch{}
              updateClearButtonVisibility();
            });
            list.appendChild(item);
          });
          col1.innerHTML=''; col1.appendChild(list);
        }
        if(col2) col2.innerHTML='<div class="mw-muted">—</div>';
        if(col3) col3.innerHTML='<div class="mw-muted">—</div>';
      });
    }

    // Rebuild labels on language change and update counts
    window.addEventListener('language-changed', ()=>{ if(!dd.hidden){ renderCol1(); renderCol2(); renderCol3(); } updateTriggerLabel(); });
    
    // Handle resize/orientation changes
    window.addEventListener('resize', ()=>{ 
      if(!dd.hidden){ 
        renderCol1(); renderCol2(); renderCol3(); 
        if(isMobile()) setMobileStage(mobileStage);
      } 
    });

    // Bootstrap cascader after DOM ready
    (function initCascader(){
      try{
        if(!casWrap) return; // silent skip
        renderCol1(); renderCol2(); renderCol3(); updateTriggerLabel();
      }catch(err){ console.error('[Cascader] init failed', err); }
    })();

    // Init
    (async function(){
      // initial lazy state: do not force load; render top column immediately
      renderCol1(); renderCol2(); renderCol3();
      applyFilter(); updateTriggerLabel();
    })();
  </script>
</body>
</html>
