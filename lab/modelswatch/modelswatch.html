<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-i18n="modelwatch_title">模型追踪器</title>
  <link rel="icon" href="../../assets/logo.svg" type="image/svg+xml">
  <meta name="theme-color" content="#0ea5e9">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' data: https:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://busuanzi.ibruce.info; font-src 'self' data:; connect-src 'self' https://busuanzi.ibruce.info; base-uri 'self'; object-src 'none'">
  <meta name="referrer" content="no-referrer-when-downgrade">
  <meta name="description" content="模型追踪器：跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <link rel="canonical" href="https://fanwan-ai.github.io/lab/modelswatch/modelswatch.html">
  <meta property="og:type" content="website">
  <meta property="og:title" content="模型追踪器" data-i18n-content="modelwatch_title">
  <meta property="og:description" content="跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <meta property="og:image" content="https://fanwan-ai.github.io/assets/placeholder.jpg">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:image:alt" content="Model Watch cover">
  <meta property="og:url" content="https://fanwan-ai.github.io/lab/modelswatch/modelswatch.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="模型追踪器" data-i18n-content="modelwatch_title">
  <meta name="twitter:description" content="跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情" data-i18n-content="modelwatch_desc">
  <meta name="twitter:image" content="https://fanwan-ai.github.io/assets/placeholder.jpg">
  <script>try{var L=localStorage.getItem('lang')||document.documentElement.lang||'zh';document.documentElement.setAttribute('lang',L);}catch(e){}</script>
  <link rel="stylesheet" href="../../style.css">
  <script defer src="../../lang.js"></script>
  <script defer src="../../script.js"></script>
  <style>
    .mw-wrap{max-width:1200px;margin:0 auto;padding:0 12px}
  /* Weekly summary removed per request */
    /* Toolbar layout */
  .mw-toolbar{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:center;padding:14px 12px}
  /* Compact toolbar tweaks: keep controls centered and reduce spacing/font-size so they fit on one line on desktop */
  .mw-toolbar.compact-override{justify-content:center;align-items:center;flex-wrap:wrap;gap:8px;padding:10px 10px}
  /* Ensure the mode buttons take a full row to avoid overflowing other controls */
  .mw-toolbar.compact-override .mw-modes{flex:0 0 100%;display:flex;justify-content:center;margin:0 0 8px 0}
  .mw-modes .btn{min-width:100px;padding:8px 12px;font-size:0.95rem}
  .mw-ds-badge{margin-left:6px;margin-top:0;padding:4px 8px;font-size:.78rem}
  .mw-ds-badge .mw-ds-tag{width:22px;height:22px;border-radius:6px;font-size:.78rem}
  /* Make DS badge visually balanced with controls: fixed height, centered, subtle shadow */
  /* Data-source badge: use theme-aware tokens so it has good contrast in light/dark */
  .mw-ds-badge{height:34px;padding:0 8px;font-size:.82rem;display:inline-flex;align-items:center;gap:8px;border-radius:999px;background:color-mix(in oklab, var(--surface-2), var(--surface) 6%);border:1px solid color-mix(in oklab, var(--border), var(--primary) 12%);box-shadow:0 6px 18px -12px rgba(16,24,40,.12);color:var(--text)}
  .mw-ds-badge .mw-ds-tag{width:24px;height:24px;border-radius:8px;font-size:.82rem;display:inline-grid;place-items:center;background:linear-gradient(135deg, color-mix(in oklab, var(--primary), white 12%), color-mix(in oklab, var(--primary-600, var(--primary)), black 6%));color:#fff}
  .mw-ds-badge .mw-ds-label{display:inline-block;font-weight:700;color:var(--text)}

  /* Slight upward nudge to visually center the DS badge with neighboring controls */
  .mw-ds-badge{align-self:center;transform:translateY(-3px)}
  .mw-cas-inline{display:flex;align-items:center}
  .mw-cas-inline .btn{padding:6px 10px;font-size:.9rem;height:34px;line-height:1;display:inline-flex;align-items:center}
  #mw-datewrap{gap:6px}
  #mw-date{height:34px;padding:4px 6px;font-size:.92rem}
  /* Make toolbar children compact by default; allow the search box to flex-grow */
  .mw-toolbar.compact-override > *{flex:0 0 auto}
  .mw-toolbar .input{height:34px;padding:6px 10px;font-size:.96rem;min-width:100px;border-radius:10px;border:1px solid var(--border);background:color-mix(in oklab,var(--surface-2),white 3%)}
  /* Search box: flexible and more prominent */
  #mw-q{flex:1 1 480px;min-width:220px;max-width:920px;padding-left:40px;background:color-mix(in oklab,var(--surface-2),white 6%);box-shadow:0 8px 22px -16px rgba(16,24,40,.12);border:1px solid color-mix(in oklab,var(--border),var(--primary) 10%)}
  /* add subtle search icon spacing if present */
  #mw-q::placeholder{color:color-mix(in oklab,var(--muted),var(--text) 24%)}
  /* Responsive fallback: allow wrapping on narrower screens */
  @media (max-width:1100px){
    .mw-toolbar.compact-override{flex-wrap:wrap}
    #mw-q{min-width:160px;max-width:100%}
    .mw-modes .btn{min-width:110px}
  }
  /* Data-source badge styling */
  /* Fallback/augment for toolbar variant: keep gradient feel but respect theme tokens for contrast */
  .mw-ds-badge{margin-left:12px;margin-top:6px;padding:6px 10px;border-radius:999px;font-weight:700;display:inline-flex;align-items:center;gap:8px;font-size:.85rem}
  @media (prefers-color-scheme: light) { .mw-ds-badge{background:linear-gradient(90deg,#eef2ff,#e6f0ff);color:#0f172a;border:1px solid rgba(59,130,246,0.12)} }
  @media (prefers-color-scheme: dark) { .mw-ds-badge{background:color-mix(in oklab, var(--surface-2), black 6%);color:var(--text);border:1px solid color-mix(in oklab, var(--border), var(--primary) 12%)} }
  .mw-ds-badge .mw-ds-tag{display:inline-grid;width:28px;height:28px;place-items:center;border-radius:8px;font-size:.88rem;background:linear-gradient(135deg, color-mix(in oklab, var(--primary), white 12%), color-mix(in oklab, var(--primary-600, var(--primary)), black 6%));color:#fff}
  @media (max-width:760px){ .mw-ds-badge{display:none;} }
  /* Modes row: first row full-width */
  .mw-modes{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;width:100%;margin-bottom:6px}
    /* Distinct, polished style for the three mode buttons (different from tag chips) */
    .mw-modes .btn{display:inline-flex;align-items:center;justify-content:center;height:44px;padding:0 18px;line-height:1;text-align:center;border-radius:999px;margin-right:0;font-weight:700;letter-spacing:.2px;min-width:180px;box-shadow:var(--shadow-sm);border:1px solid color-mix(in oklab, var(--border), var(--primary) 14%)}
    /* Active state: brand gradient pill */
    .mw-modes .btn.primary{background:linear-gradient(135deg, var(--primary) 0%, var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab, var(--primary-600), white 10%);box-shadow:0 8px 18px rgba(37,99,235,0.18)}
    .mw-modes .btn.primary:hover{transform:translateY(-1px);box-shadow:0 10px 22px rgba(37,99,235,0.24)}
    /* Inactive state: soft glass-like pill */
    .mw-modes .btn.outline{background:color-mix(in oklab, var(--surface), white 6%);color:color-mix(in oklab, var(--text), var(--muted) 12%);border-color:color-mix(in oklab, var(--border), var(--primary) 22%)}
    .mw-modes .btn.outline:hover{background:color-mix(in oklab, var(--surface), var(--primary) 8%);color:var(--text)}
    /* Dark theme tuning */
    :root[data-theme="dark"] .mw-modes .btn.primary{box-shadow:0 10px 24px rgba(59,130,246,0.25)}
    :root[data-theme="dark"] .mw-modes .btn.outline{background:color-mix(in oklab, var(--surface), black 6%);color:#e5e7eb;border-color:color-mix(in oklab, var(--border), var(--primary) 25%)}
    @media (max-width:560px){.mw-modes .btn{min-width:auto;flex:1 1 auto;padding:0 14px;height:42px}}
  /* Unified control sizing and aesthetics */
  :root{ --mw-ctrl-h: 38px; --mw-radius: 10px; }
  .mw-toolbar .input{height:var(--mw-ctrl-h);padding:6px 12px;border-radius:var(--mw-radius);border:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);background:color-mix(in oklab, var(--surface-2), white 2%);box-shadow:var(--shadow-sm)}
  .mw-toolbar .btn.small{height:var(--mw-ctrl-h);padding:0 12px;border-radius:var(--mw-radius)}
  /* Date group: segmented control with equal spacing */
  #mw-datewrap{gap:0!important;border:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-radius:var(--mw-radius);overflow:hidden;background:color-mix(in oklab, var(--surface-2), white 2%);box-shadow:var(--shadow-sm);padding:0 8px}
  #mw-datewrap .btn{border:none;border-right:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);width:var(--mw-ctrl-h);display:inline-grid;place-items:center;padding:0}
  #mw-datewrap .btn:last-child{border-right:none}
  #mw-datewrap .input{border:none;border-left:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-right:1px solid color-mix(in oklab, var(--border), var(--primary) 18%);border-radius:0;height:var(--mw-ctrl-h);box-shadow:none;background:transparent}
  /* Cascader trigger: pill appearance */
  .mw-cas-inline > #mw-cas-trigger{font-weight:600}
  /* Active state for trigger when filters applied */
  .mw-cas-inline > #mw-cas-trigger.active{background:linear-gradient(135deg, var(--primary) 0%, var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab, var(--primary-600), white 10%);box-shadow:0 8px 18px rgba(37,99,235,.18)}
  /* Search input: add subtle search icon */
  #mw-q{padding-left:34px;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='none' stroke='%2399a3ad' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:10px center;color:var(--text)}
  #mw-q::placeholder{color:color-mix(in oklab, var(--muted), var(--text) 25%)}
  :root[data-theme="dark"] #mw-q{color:#111;background:#fff;border-color:color-mix(in oklab, var(--border), white 35%)}
  :root[data-theme="dark"] #mw-q::placeholder{color:#555}
  /* Dark theme cascader trigger & clear button accessibility */
  :root[data-theme="dark"] #mw-cas-trigger{background:#fff;color:#111;border:1px solid color-mix(in oklab,var(--border),white 35%);transition:background .15s,color .15s,border-color .15s}
  :root[data-theme="dark"] #mw-cas-trigger:hover{background:#f1f5f9}
  :root[data-theme="dark"] #mw-cas-trigger.active{background:#e2e8f0;border-color:#cbd5e1}
  :root[data-theme="dark"] #mw-cas-clear{background:#fff;color:#111;border:1px solid color-mix(in oklab,var(--border),white 35%)}
  :root[data-theme="dark"] #mw-cas-clear:hover{background:#fee2e2;color:#991b1b;border-color:#fca5a5}
  :root[data-theme="dark"] #mw-cas-clear:active{background:#fecaca}
  :root[data-theme="dark"] #mw-cas-clear:focus-visible{outline:2px solid #ef4444;outline-offset:2px}
  /* Date input contrast */
  #mw-date{color:var(--text);background:transparent}
  #mw-date::placeholder{color:color-mix(in oklab, var(--muted), var(--text) 30%)}
  :root[data-theme="dark"] #mw-date{color:#111;background:#fff;border:1px solid color-mix(in oklab, var(--border), white 35%);border-radius:var(--mw-radius)}
  :root[data-theme="dark"] #mw-date::placeholder{color:#555}
  :root[data-theme="dark"] #mw-sort{color:#111;background:#fff;border:1px solid color-mix(in oklab, var(--border), white 35%)}
  :root[data-theme="dark"] #mw-datewrap{background:#fff}
  :root[data-theme="dark"] #mw-datewrap .btn{background:#fff;color:#111}
  :root[data-theme="dark"] #mw-datewrap .btn:hover{background:#f2f2f2}
  :root[data-theme="dark"] .mw-toolbar .input{background:#fff;color:#111}
  :root[data-theme="dark"] .mw-toolbar .btn.small{background:color-mix(in oklab, #fff, var(--primary) 4%);color:#111}
  :root[data-theme="dark"] .mw-toolbar .btn.small.active, :root[data-theme="dark"] .mw-toolbar .btn.small:focus{color:#111}
  .mw-highlight{background:color-mix(in oklab, var(--primary) 25%, transparent);padding:0 2px;border-radius:4px}
  :root[data-theme="dark"] .mw-highlight{background:rgba(59,130,246,.35)}
  @media (max-width:800px){ .mw-toolbar .input{flex:1 1 220px} }
    .mw-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
    @media (max-width:1100px){.mw-grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
    @media (max-width:700px){.mw-grid{grid-template-columns:1fr;}}
    .mw-card{padding:12px}
    .mw-title{font-size:1.05rem;margin:0 0 4px 0;line-height:1.35}
  .mw-title a{color:var(--primary);text-decoration:none}
  .mw-title a:hover{text-decoration:underline}
    .mw-meta{font-size:.85rem;color:var(--muted);display:flex;gap:6px;flex-wrap:wrap}
  .mw-tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  /* Reason + multi-list badges */
  .mw-badges{display:flex;gap:4px;flex-wrap:wrap;margin:4px 0 2px}
  .mw-badge{display:inline-flex;align-items:center;font-size:.65rem;font-weight:600;letter-spacing:.3px;padding:4px 8px;border-radius:999px;line-height:1;background:color-mix(in oklab,var(--surface-2),var(--primary) 14%);color:color-mix(in oklab,var(--primary-700,#1d4ed8),black 10%);border:1px solid color-mix(in oklab,var(--primary) 55%,var(--border));position:relative}
  .mw-badge[data-type="reason"]{background:linear-gradient(135deg,var(--primary) 0%,var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab,var(--primary-600),white 10%)}
  .mw-badge[data-type="multi"]{background:color-mix(in oklab,var(--warning,#fbbf24),white 8%);color:#92400e;border-color:color-mix(in oklab,#f59e0b,#78350f 40%)}
  :root[data-theme="dark"] .mw-badge{background:color-mix(in oklab,var(--primary-900,#1e3a8a),black 8%);color:#e2e8f0;border-color:color-mix(in oklab,var(--primary-500,#3b82f6),#1e293b 30%)}
  :root[data-theme="dark"] .mw-badge[data-type="reason"]{background:linear-gradient(135deg,var(--primary-400,#60a5fa) 0%,var(--primary-700,#1d4ed8) 100%);color:#fff}
  :root[data-theme="dark"] .mw-badge[data-type="multi"]{background:color-mix(in oklab,#92400e,#fbbf24 25%);color:#fff;border-color:#fbbf24}
    .mw-spark{width:100%;height:54px}
    .mw-aside{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:12px}
    @media (max-width:900px){.mw-aside{grid-template-columns:repeat(2,minmax(0,1fr));}}
    .mw-leader{padding:12px}
    .mw-leader h3{margin:0 0 6px 0;font-size:1rem;color:var(--secondary)}
    .mw-leader ol{margin:0;padding-left:1.1rem;display:grid;gap:.35rem}
    .mw-leader a{color:var(--link);text-decoration:none}
    .mw-leader a:hover{text-decoration:underline}
    .mw-chiprow{display:flex;gap:6px;flex-wrap:wrap}
    /* Compact toolbar wrapping */
    .mw-toolbar{gap:8px}
    .mw-toolbar .input{min-width:160px}
    @media (max-width:800px){ .mw-toolbar .input{flex:1 1 220px} }
    .mw-modal[hidden]{display:none!important}
    .mw-modal{position:fixed;inset:0;display:grid;place-items:center;z-index:2000}
    .mw-modal .backdrop{position:absolute;inset:0;background:rgba(2,6,23,.55)}
    .mw-dialog{position:relative;background:var(--surface);border:1px solid var(--border);border-radius:12px;box-shadow:var(--shadow-md);width:min(96vw,1100px);height:min(92vh,760px);display:flex;flex-direction:column;overflow:hidden}
    .mw-dialog .head{display:flex;align-items:center;justify-content:space-between;padding:.65rem 1rem;border-bottom:1px solid var(--border);background:var(--surface-2)}
    .mw-dialog .body{flex:1;overflow:auto;padding:10px}
    /* Daily sections */
    .mw-sec-title{margin:10px 0 8px;color:var(--secondary);font-weight:600}
    .mw-sec-sep{margin:16px 0;border:none;border-top:1px dashed var(--border)}
  </style>
  <!-- Styles: Cascading category filter (三级联动) -->
  <style>
    /* 样式定义：三级联动标签筛选 */
    .mw-cascader { margin-top: 10px; padding: 10px; }
    .mw-cascader { position: relative; }
    .mw-cas-section { margin: 6px 0 8px; }
    .mw-cas-row { display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .mw-cas-top { display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; margin: 6px 0; }
    .mw-cas-title { font-weight:600; color: var(--secondary); margin: 4px 0; font-size: .95rem; }
    .mw-cas-sub { margin: 4px 0 0 0; padding-left: 4px; border-left: 2px solid var(--border); }
    .mw-cas-hidden { display:none; }
    /* 一级/二级按钮沿用现有圆角按钮风格 */
    .mw-cas-row .btn, .mw-cas-top .btn { height: 34px; padding: 0 12px; border-radius: 999px; font-size: .9rem; }
    .mw-cas-row .btn.primary { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.28)); color: color-mix(in oklab, var(--primary), black 10%); border-color: color-mix(in oklab, var(--primary), var(--border) 50%); }
    /* 三级任务：复用现有 .tag 标签风格，附加选中高亮 */
    .mw-task { cursor: pointer; user-select: none; }
    .mw-task.active { background: color-mix(in oklab, var(--primary) 18%, white); color: color-mix(in oklab, var(--primary), black 20%); border-color: color-mix(in oklab, var(--primary), var(--border) 40%); }
    :root[data-theme="dark"] .mw-task.active { background: rgba(59,130,246,0.22); color: #e5e7eb; border-color: rgba(59,130,246,0.42); }
    /* 命中卡片高亮（可选，卡片同时被筛选显示） */
    .mw-card.mw-hit { border-color: color-mix(in oklab, var(--primary) 38%, var(--border)); box-shadow: 0 6px 18px rgba(59,130,246,0.18); }
    .mw-cas-tools { display:flex; gap:6px; align-items:center; margin-top: 6px; }

    /* 下拉面板（多列级联选择） */
  .mw-cas-dd { position: absolute; top: 42px; left: 0; z-index: 50; background: var(--surface); border: 1px solid color-mix(in oklab, var(--border), var(--primary) 15%); border-radius: 14px; box-shadow: 0 16px 40px rgba(2,6,23,.18); width: min(92vw, 920px); overflow:hidden }
    .mw-cas-dd .dd-body { display: grid; grid-template-columns: 1.05fr 1.25fr 1.6fr; gap: 0; min-height: 260px; max-height: 62vh; overflow: hidden; }
    .mw-cas-dd .col { border-right: 1px solid var(--border); padding: 10px; overflow: auto; background: color-mix(in oklab, var(--surface), white 2%); }
    .mw-cas-dd .col:nth-child(2){ background: color-mix(in oklab, var(--surface), var(--primary) 3%); }
    .mw-cas-dd .col:last-child { border-right: none; background: color-mix(in oklab, var(--surface), var(--primary) 6%); }
    .mw-cas-dd .dd-foot { display:flex; justify-content: flex-end; gap:10px; padding: 10px; border-top: 1px solid var(--border); background: var(--surface-2); }
  /* Cascader 'All dates' toggle visual states */
  #mw-toggle-all-cas{border-radius:8px;padding:6px 10px;font-weight:600}
  #mw-toggle-all-cas.active{background:linear-gradient(135deg,var(--primary) 0%,var(--primary-600) 100%);color:#fff;border-color:color-mix(in oklab,var(--primary-600),white 10%);box-shadow:0 8px 18px rgba(37,99,235,0.18)}
  @media (prefers-color-scheme: dark){ #mw-toggle-all-cas.active{box-shadow:0 10px 24px rgba(59,130,246,0.25)} }
    .mw-cas-dd.mw-single-col { width: min(92vw, 340px); }
    .mw-cas-dd.mw-single-col .dd-body { grid-template-columns: 1fr; }
    .mw-list { display:grid; gap:6px; }
    .mw-item { display:flex; align-items:center; gap:10px; padding:8px 10px; border-radius:10px; cursor:pointer; position:relative; transition: background .15s ease, transform .08s ease; }
    .mw-item::before{content:""; position:absolute; left:4px; top:8px; bottom:8px; width:3px; border-radius:3px; background:transparent}
    .mw-item:hover { background: color-mix(in oklab, var(--surface-2), var(--primary) 10%); }
    .mw-item.active { background: color-mix(in oklab, var(--primary) 14%, white); box-shadow: var(--shadow-sm); }
    .mw-item.active::before{ background: color-mix(in oklab, var(--primary), white 10%); }
    :root[data-theme="dark"] .mw-item.active { background: rgba(59,130,246,0.2); }
    .mw-check { width: 18px; height: 18px; border: 1.5px solid color-mix(in oklab, var(--border), var(--primary) 20%); border-radius: 6px; display:inline-grid; place-items:center; background: var(--surface); color: #fff; font-size:14px; line-height:1; }
    .mw-check[data-on="1"] { border-color: color-mix(in oklab, var(--primary), var(--border) 10%); background: color-mix(in oklab, var(--primary) 28%, white); }
    .mw-muted { color: var(--muted); font-size: .9rem; padding: 10px; }
    /* Mobile cascader - staged navigation */
    @media (max-width: 800px){ 
      .mw-cas-dd .dd-body { grid-template-columns: 1fr; position: relative; overflow: hidden; } 
      .mw-cas-dd { left: 0; width: 100%; max-width: 100vw; } 
      .mw-item{padding:12px 12px; font-size: 16px; -webkit-tap-highlight-color: transparent; }
      .mw-cas-dd .col { border-right: none; position: absolute; width: 100%; height: 100%; transition: transform 0.3s ease; }
      .mw-cas-dd .col.stage-0 { transform: translateX(0); }
      .mw-cas-dd .col.stage-1 { transform: translateX(100%); }
      .mw-cas-dd .col.stage-2 { transform: translateX(200%); }
      .mw-cas-dd .col.stage-active { transform: translateX(0) !important; }
      .mw-cas-dd .col.stage-hidden { transform: translateX(-100%) !important; }
      .mw-mobile-nav { display: flex; align-items: center; padding: 8px 10px; border-bottom: 1px solid var(--border); background: var(--surface-2); }
      .mw-mobile-back { background: none; border: none; color: var(--primary); font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 4px; }
      .mw-mobile-title { flex: 1; font-weight: 600; color: var(--secondary); text-align: center; font-size: 14px; }
    }
  </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to main content</a>
  <header>
    <nav class="navbar container">
      <a href="../../index.html" class="brand" aria-label="Home">
        <img src="../../assets/logo.svg" alt="Fan Wan logo" class="brand-logo" width="28" height="28" />
        <span class="logo"><span class="i18n l-zh">首页</span><span class="i18n l-en">Home</span><span class="i18n l-es">Inicio</span></span>
      </a>
      <ul class="nav-links">
        <li><a href="../../index.html"><span class="icon" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M3 12l9-9 9 9"/><path d="M9 21V9h6v12"/></svg></span> <span class="i18n l-zh">首页</span><span class="i18n l-en">Home</span><span class="i18n l-es">Inicio</span></a></li>
        <li><a href="../../about.html"><span class="i18n l-zh">关于我</span><span class="i18n l-en">About</span><span class="i18n l-es">Acerca de</span></a></li>
        <li><a href="../../publications.html"><span class="i18n l-zh">学术出版物</span><span class="i18n l-en">Research</span><span class="i18n l-es">Investigación</span></a></li>
        <li><a href="../../blog.html"><span class="i18n l-zh">博客</span><span class="i18n l-en">Blog</span><span class="i18n l-es">Blog</span></a></li>
        <li><a href="../../ai-lab.html"><span class="i18n l-zh">AI Studio</span><span class="i18n l-en">AI Studio</span><span class="i18n l-es">Taller de IA</span></a></li>
        <li><a href="../../contact.html"><span class="i18n l-zh">联系</span><span class="i18n l-en">Contact</span><span class="i18n l-es">Contacto</span></a></li>
      </ul>
      <div class="nav-actions">
        <div class="lang-switcher">
          <button id="lang-button" class="btn outline icon-btn" aria-haspopup="listbox" aria-expanded="false">
            <svg class="icon icon-globe" viewBox="0 0 24 24" aria-hidden="true"><g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"/><path d="M3 12h18M12 3a15 15 0 0 1 0 18M12 3a15 15 0 0 0 0 18"/></g></svg>
            <span class="label"></span>
          </button>
          <ul id="lang-menu" class="lang-menu" role="listbox" aria-label="Language" hidden>
            <li role="option" data-lang="en">English</li>
            <li role="option" data-lang="zh">中文</li>
            <li role="option" data-lang="es">Español</li>
          </ul>
          <select id="lang-select" hidden>
            <option value="en">English</option>
            <option value="zh">中文</option>
            <option value="es">Español</option>
          </select>
        </div>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme" title="Toggle theme">
          <svg class="icon icon-bulb" viewBox="0 0 24 24" aria-hidden="true">
            <g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 18h6"/>
              <path d="M10 22h4"/>
              <path d="M8.5 15.5c-.9-1-1.5-2.3-1.5-3.8a5 5 0 1 1 10 0c0 1.5-.6 2.8-1.5 3.8-.6.7-1.1 1.4-1.3 2.2H9.8c-.2-.8-.7-1.5-1.3-2.2z"/>
              <path d="M12 2v2"/>
              <path d="M4 10h2"/>
              <path d="M18 10h2"/>
              <path d="M5.5 5.5l1.4 1.4"/>
              <path d="M18.5 5.5l-1.4 1.4"/>
            </g>
          </svg>
          <svg class="icon icon-moon" viewBox="0 0 24 24" aria-hidden="true"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <svg class="icon icon-system" viewBox="0 0 24 24" aria-hidden="true"><g fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="12" rx="2" ry="2"/><path d="M8 20h8M12 16v4"/></g></svg>
        </button>
        <div class="hamburger" id="hamburger">
          <span></span><span></span><span></span>
        </div>
      </div>
    </nav>
  </header>

  <main id="main">
    <section class="page-hero section">
      <div class="bg-shapes">
        <span class="shape shape1"></span>
        <span class="shape shape2"></span>
        <span class="shape shape3"></span>
        <span class="shape shape4"></span>
      </div>
      <div class="container">
        <h1 data-i18n="modelwatch_title">模型追踪器</h1>
        <p class="subtitle" data-i18n="modelwatch_desc">跟踪 GitHub 与 Hugging Face 热门模型/项目的热度趋势、榜单与详情</p>
      </div>
    </section>

    <section class="section">
      <div class="container mw-wrap">
        <!-- Weekly summary removed -->
  <div class="card mw-card mw-toolbar compact-override" role="toolbar" aria-label="Filters">
          <div class="mw-modes" id="mw-modes">
            <button class="btn primary" data-mode="daily" data-i18n="mw_mode_daily">今日灵感</button>
            <button class="btn outline" data-mode="gh" data-i18n="mw_mode_gh_top">工程热榜</button>
            <button class="btn outline" data-mode="hf" data-i18n="mw_mode_hf_top">模型实验场</button>
          </div>
          <div id="mw-datasource" class="mw-ds-badge" aria-hidden="true"><span class="mw-ds-tag">DS</span><span class="mw-ds-label">数据源：—</span></div>
          <div class="mw-cas-inline" style="position:relative;display:flex;align-items:center;gap:12px">
            <button class="btn outline small" id="mw-cas-trigger" data-mode-label="model"><span class="i18n l-zh">按类别查看模型</span><span class="i18n l-en">Browse by Category</span><span class="i18n l-es">Ver por categoría</span></button>
            <!-- 下拉面板：三级级联（单选/单选/多选） -->
            <div class="mw-cas-dd" id="mw-cas-dd" hidden>
              <div class="dd-body">
                <div class="col" id="mw-cas-c1"><div class="mw-muted">—</div></div>
                <div class="col" id="mw-cas-c2"><div class="mw-muted">—</div></div>
                <div class="col" id="mw-cas-c3"><div class="mw-muted">—</div></div>
              </div>
              <div class="dd-foot">
                <div style="display:flex;align-items:center;gap:8px">
                  <button id="mw-toggle-all-cas" class="btn outline small" title="跨历史搜索（可能较慢）" aria-pressed="false">
                    <span class="i18n l-zh">跨历史搜索</span>
                    <span class="i18n l-en">All dates</span>
                    <span class="i18n l-es">Todas fechas</span>
                  </button>
                  <button class="btn outline small" id="mw-cas-close" title="应用当前所选的类别/任务并显示结果" aria-label="应用筛选">
                    <span class="i18n l-zh">应用筛选</span>
                    <span class="i18n l-en">Apply filters</span>
                    <span class="i18n l-es">Aplicar filtros</span>
                  </button>
                  <span id="mw-load-progress" style="margin-left:8px;color:var(--muted);font-size:0.92rem;display:none">加载中…</span>
                </div>
              </div>
            </div>
          </div>
          <div id="mw-datewrap" style="display:flex;align-items:center" hidden>
            <button id="mw-prev" class="btn outline small" title="Prev day" aria-label="Previous day">
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path d="M15 6l-6 6 6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
            <input type="date" id="mw-date" class="input" style="height:36px;padding:6px 8px" />
            <button id="mw-next" class="btn outline small" title="Next day" aria-label="Next day">
              <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 6l6 6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
          </div>
          <button id="mw-view-snapshot" class="btn outline small" title="View snapshot" aria-label="View snapshot" disabled>
            <span class="i18n l-zh">查看快照</span><span class="i18n l-en">View snapshot</span><span class="i18n l-es">Ver instantánea</span>
          </button>
          <select id="mw-sort" class="input">
            <option value="score" data-i18n="mw_sort_score">综合分</option>
            <option value="delta7" data-i18n="mw_sort_delta7">7日增量</option>
            <option value="stars" data-i18n="mw_sort_stars">Stars</option>
            <option value="downloads" data-i18n="mw_sort_downloads">Downloads</option>
            <option value="stars7" data-i18n="mw_sort_stars7">Stars 7日</option>
            <option value="forks7" data-i18n="mw_sort_forks7">Forks 7日</option>
            <option value="downloads7" data-i18n="mw_sort_downloads7">下载 7日</option>
            <option value="likes7" data-i18n="mw_sort_likes7">Likes 7日</option>
          </select>
          <input id="mw-q" class="input" placeholder="搜索标题/摘要/来源…" data-i18n-placeholder="search_placeholder" />
          <button class="btn outline small" id="mw-cas-clear"><span class="i18n l-zh">清空筛选</span><span class="i18n l-en">Clear</span><span class="i18n l-es">Limpiar</span></button>
        </div>

        <div style="margin:12px 0 6px 0" class="muted" id="mw-sub">—</div>

        <!-- 分类级联已集成在工具栏中 -->

        <div class="mw-grid" id="mw-grid"></div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container site-footer-center">
      <p>© <span id="year"></span> Fan Wan</p>
    </div>
  </footer>

  <div class="mw-modal" id="mw-modal" hidden>
    <div class="backdrop" onclick="document.getElementById('mw-modal').hidden=true"></div>
    <div class="mw-dialog">
      <div class="head">
        <strong id="mw-modal-title">—</strong>
        <button class="modal-close" onclick="document.getElementById('mw-modal').hidden=true">✕</button>
      </div>
      <div class="body" id="mw-modal-body"></div>
    </div>
  </div>

  <script>
  (function(){
    const modesEl = document.getElementById('mw-modes');
    const sortEl = document.getElementById('mw-sort');
    const qEl = document.getElementById('mw-q');
  // (gridEl/subEl not needed inside cascader context for dropdown operations)
  const dateWrap = document.getElementById('mw-datewrap');
  const dateInput = document.getElementById('mw-date');
  const prevBtn = document.getElementById('mw-prev');
  const nextBtn = document.getElementById('mw-next');
    const $ = (id)=>document.getElementById(id);

    let MODE = 'daily';
    const SCHEMA_VERSION = 1; // Sync with backend schema.js
    let items = [];
    let catsLoaded = false;
  // no dedicated model picker
    let query = '';
  let availableDates = [];
  let selectedDate = '';
    // Global aggregation cache for Daily across all dates
    let itemsAll = [];
    let allLoaded = false;
  let useAllDatesForFilter = false; // when true, filters/search operate on itemsAll (all dates)
    let globalActive = false;

    function isGlobalActive(){ return globalActive; }
    function setGlobalActive(on){
      globalActive = !!on;
      try{
        dateWrap.hidden = globalActive || (MODE !== 'daily');
        subEl.hidden = globalActive;
      }catch{}
    }

    // Transient hint / toast helper (injects minimal styles and shows a short message)
    (function(){
      let _hintStyleInjected = false;
      function ensureHintStyle(){
        if(_hintStyleInjected) return;
        _hintStyleInjected = true;
        try{
          const s = document.createElement('style');
          s.textContent = `
          /* Transient hint: use theme tokens so contrast is correct in light/dark */
          .mw-transient-hint{position:fixed;right:20px;top:86px;z-index:1200;padding:8px 12px;border-radius:8px;font-size:13px;opacity:0;transform:translateY(-6px);transition:opacity .22s ease,transform .22s ease;box-shadow:0 6px 18px rgba(2,6,23,0.18);}
          .mw-transient-hint.show{opacity:1;transform:translateY(0)}
          /* Light theme: subtle dark text on pale surface */
          @media (prefers-color-scheme: light) { .mw-transient-hint{background: color-mix(in oklab, var(--surface), white 92%); color: var(--text); border:1px solid color-mix(in oklab, var(--border), black 6%);} }
          /* Dark theme: light text on slightly elevated dark surface */
          @media (prefers-color-scheme: dark) { .mw-transient-hint{background: color-mix(in oklab, var(--surface), black 6%); color: var(--text); border:1px solid color-mix(in oklab, var(--border), black 10%);} }
          /* Override if explicit theme attribute present */
          :root[data-theme="light"] .mw-transient-hint{background: color-mix(in oklab, var(--surface), white 92%); color: var(--text); border:1px solid color-mix(in oklab, var(--border), black 6%);} 
          :root[data-theme="dark"] .mw-transient-hint{background: color-mix(in oklab, var(--surface), black 6%); color: var(--text); border:1px solid color-mix(in oklab, var(--border), black 10%);} 
          @media(max-width:800px){ .mw-transient-hint{left:12px;right:12px;top:64px} }
          `;
          document.head.appendChild(s);
        }catch{}
      }
      window.showTransientHint = function(msg, ms){
        try{
          ensureHintStyle();
          let el = document.getElementById('mw-transient-hint');
          if(!el){ el = document.createElement('div'); el.id = 'mw-transient-hint'; el.className = 'mw-transient-hint'; document.body.appendChild(el); }
          el.textContent = msg;
          // trigger show
          requestAnimationFrame(()=> el.classList.add('show'));
          if(ms===undefined) ms = 2800;
          clearTimeout(el._mw_to);
          el._mw_to = setTimeout(()=>{ try{ el.classList.remove('show'); }catch{}; }, ms);
        }catch{}
      };
    })();

    // Fallback canonical categories and labels (used if categories.json not found)
    let CANON = {
      capabilities: ['chat','multimodal','retrieval','code','speech','video','vision','planning','safety','compression','distillation'],
      scenes: ['devex','education','research','search','content','productization','robotics'],
      lifecycle: ['data','training','evaluation','deployment','inference','monitoring']
    };
    let TAG_LABELS = {
      zh: { chat:'对话', multimodal:'多模态', retrieval:'检索', code:'代码', speech:'语音', video:'视频', vision:'视觉', planning:'规划', safety:'安全', compression:'压缩', distillation:'蒸馏', devex:'DevEx', education:'教育', research:'科研', search:'搜索', content:'内容生成', productization:'产品化', robotics:'机器人', data:'数据', training:'训练', evaluation:'评测', deployment:'部署', inference:'推理', monitoring:'监控' },
      en: { chat:'Chat', multimodal:'Multimodal', retrieval:'Retrieval', code:'Code', speech:'Speech', video:'Video', vision:'Vision', planning:'Planning', safety:'Safety', compression:'Compression', distillation:'Distillation', devex:'DevEx', education:'Education', research:'Research', search:'Search', content:'Content Gen', productization:'Productization', robotics:'Robotics', data:'Data', training:'Training', evaluation:'Evaluation', deployment:'Deployment', inference:'Inference', monitoring:'Monitoring' },
      es: { chat:'Conversación', multimodal:'Multimodal', retrieval:'Recuperación', code:'Código', speech:'Voz', video:'Vídeo', vision:'Visión', planning:'Planificación', safety:'Seguridad', compression:'Compresión', distillation:'Destilación', devex:'DevEx', education:'Educación', research:'Investigación', search:'Búsqueda', content:'Generación de contenido', productization:'Productización', robotics:'Robótica', data:'Datos', training:'Entrenamiento', evaluation:'Evaluación', deployment:'Despliegue', inference:'Inferencia', monitoring:'Monitorización' }
    };

    // Build reverse map from any label to canonical key (kept for deriving categories)
    let LABEL_TO_KEY = {};
    (function rebuildLabelIndex(){
      const m = {};
      for(const lang of Object.keys(TAG_LABELS)){
        const dict = TAG_LABELS[lang]||{};
        for(const k of Object.keys(dict)) m[dict[k]] = k;
      }
      for(const group of Object.values(CANON)) for(const k of group) m[k] = k;
      LABEL_TO_KEY = m;
    })();

    // Unified language resolver with optional override and graceful fallback.
    // Usage: const L = getLang(); or getLang('es'); Only returns zh/en/es, defaults to zh.
    function getLang(preferred){
      const order = [preferred, localStorage.getItem('lang'), document.documentElement.getAttribute('data-lang'), document.documentElement.lang, 'zh'];
      for(const v of order){ if(typeof v === 'string' && ['zh','en','es'].includes(v)) return v; }
      return 'zh';
    }
    window.getLang = getLang; // expose
    const tagLabel = (key)=> TAG_LABELS[getLang()]?.[key] || key;
    const toKey = (s)=> LABEL_TO_KEY[String(s||'').trim()] || null;
  function string(s){ return String(s); }

    function t(key, fallback){ try { const lang = localStorage.getItem('lang')||document.documentElement.lang||'zh'; const tx=(window.translations?.[lang]?.[key]); return tx||fallback||key; } catch { return fallback||key; } }

    function esc(s){return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');}
    // Weekly summary removed per request
    function normalizeStats(it){ if(!it||!it.stats) return it; const s=it.stats; if(s.hf_downloads_7d && !s.downloads_total) s.downloads_total = s.hf_downloads_7d; if(s.hf_likes && !s.likes_total) s.likes_total = s.hf_likes; return it; }
    function normalizeArray(arr){ return (arr||[]).map(normalizeStats); }
    function rel(iso){ try{ const d=new Date(iso); const s=(Date.now()-d)/1000; if(s<60) return 'just now'; if(s<3600) return Math.floor(s/60)+'m'; if(s<86400) return Math.floor(s/3600)+'h'; return Math.floor(s/86400)+'d'; }catch{return ''} }

    // Compute a robust updated_at string (ISO) using meta.updated_at, max item.updated_at, or a date hint
    function toIso(x){
      try{ const t = new Date(x); if(!isNaN(t)) return t.toISOString(); }catch{}
      return '';
    }
    function computeUpdatedAt(metaUpdatedAt, arr, dateHint){
      const cands = [];
      const mIso = toIso(metaUpdatedAt); if(mIso) cands.push(mIso);
      if(Array.isArray(arr)){
        for(const it of arr){
          const u = it?.updated_at || it?.stats?.updated_at;
          const iso = toIso(u); if(iso) cands.push(iso);
        }
      }
      if(!cands.length && dateHint){
        // fallback to the hint date at noon UTC to avoid TZ-aliasing to previous day
        const iso = toIso(`${dateHint}T12:00:00Z`);
        if(iso) cands.push(iso);
      }
      if(!cands.length) return new Date().toISOString();
      // pick the latest
      return cands.reduce((a,b)=> a>b?a:b);
    }

    // Recent-repeat configuration: penalize items that appeared in the past K days
    const RECENT_REPEAT_DAYS = 90; // default as requested
    const RECENT_REPEAT_PENALTY = 40; // numerical score penalty applied when item seen in recent window
    let _recentIdSet = null; // cached Set of normalized keys seen in recent window

    // No top chips anymore

    function sparkline(ts=[], vals=[], color){
      // Lightweight inline SVG sparkline (last 30 pts or fewer)
      const N = Math.min(vals.length, 30);
      const sliceVals = vals.slice(-N);
      const sliceTs = ts.slice(-N);
      if (!sliceVals.length) return '';
      const W=280, H=54, L=0, R=0, T=6, B=12; const iw=W-L-R, ih=H-T-B;
      const minX = sliceTs[0], maxX = sliceTs[sliceTs.length-1];
      const minY = Math.min(...sliceVals, 0), maxY = Math.max(...sliceVals);
      const xPos = (t)=> L + ( (t-minX)/Math.max(1,(maxX-minX)) )*iw;
      const yPos = (v)=> T + ih - ( (v-minY)/Math.max(1,(maxY-minY)) )*ih;
      let d='';
      for(let i=0;i<sliceVals.length;i++){
        const x=xPos(sliceTs[i]); const y=yPos(sliceVals[i]); d+= (i?` L ${x},${y}`:`M ${x},${y}`);
      }
      const stroke=color||'#0ea5e9';
      return `<svg class="mw-spark" viewBox="0 0 ${W} ${H}" width="${W}" height="${H}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <defs>
          <linearGradient id="sg" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="${stroke}"/>
            <stop offset="100%" stop-color="${stroke}" stop-opacity="0.25"/>
          </linearGradient>
        </defs>
        <path d="${d}" fill="none" stroke="url(#sg)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>`;
    }

    // Normalize an item's identity for robust deduplication across sources/urls/naming
    function normalizeKey(it){
      try{
        const raw = (it && (it.id || it.url || it.name)) || '';
        if(!raw) return '';
        let s = String(raw).trim().toLowerCase();
        // remove protocol
        s = s.replace(/^https?:\/\//,'');
        // remove www
        s = s.replace(/^www\./,'');
        // remove trailing slash
        s = s.replace(/\/?$/,'');
        // canonicalize GitHub repo urls (owner/repo)
        s = s.replace(/^github\.com\//,'');
        // canonicalize HF model urls
        s = s.replace(/^huggingface\.co\//,'');
        // strip common query/hash
        s = s.split(/[?#]/)[0];
        // collapse multiple non-alphanum into single dash for safer key
        s = s.replace(/[^a-z0-9\/]+/g,'-');
        // trim dashes
        s = s.replace(/(^-+|-+$)/g,'');
        return s;
      }catch{ return String((it && (it.id||it.url||it.name))||'').toLowerCase(); }
    }

    // Collect normalized ids for the recent window (non-blocking). Returns a Set.
    async function getRecentIdSet(days){
      try{
        if(_recentIdSet) return _recentIdSet;
        _recentIdSet = new Set();
        const n = Number(days) || RECENT_REPEAT_DAYS;
        // prefer availableDates if present (most recent first)
        let dates = Array.isArray(availableDates) && availableDates.length? availableDates.slice() : [];
        if(dates.length===0){ dates = candidateRecentDates(Math.min(n, 30)); }
        // take most recent 'n' dates (availableDates is expected sorted desc)
        dates = dates.slice(0, n);
        const chunk = 8;
        for(let i=0;i<dates.length;i+=chunk){
          const batch = dates.slice(i, i+chunk);
          const res = await Promise.allSettled(batch.map(d=> fetch(`../../data/ai/modelswatch/daily/${d}.json`, {cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null)));
          for(const r of res){
            if(r.status==='fulfilled' && r.value && Array.isArray(r.value.items)){
              for(const it of r.value.items){ const k = normalizeKey(it); if(k) _recentIdSet.add(k); }
            }
          }
        }
  // recent id set populated
        return _recentIdSet;
      }catch(e){ console.warn('[mw] getRecentIdSet error', e); return _recentIdSet || new Set(); }
    }

    // Simple keyword mapping to canonical categories (multilingual hints)
    const KEYWORDS = {
      chat: [/\bchat\b/i, /对话/, /assistant/i],
      multimodal: [/multimodal/i, /多模态/],
      retrieval: [/retriev/i, /RAG/i, /检索/],
      code: [/\bcode\b/i, /编程/, /coder/i],
      speech: [/speech/i, /audio/i, /语音/],
      video: [/video/i, /视频/],
      vision: [/vision/i, /图像/, /视觉/],
      planning: [/plan/i, /规划/],
      safety: [/safety/i, /安全/],
      compression: [/compress/i, /压缩/],
      distillation: [/distill/i, /蒸馏/],
      devex: [/devex/i, /developer/i],
      education: [/educat/i, /教育/],
      research: [/research/i, /科研/],
      search: [/search/i, /搜索/],
      content: [/content/i, /生成/],
      productization: [/product/i, /产品化/],
      robotics: [/robot/i, /机器人/],
      data: [/data/i, /数据/],
      training: [/train/i, /训练/],
      evaluation: [/eval/i, /评测/],
      deployment: [/deploy/i, /部署/],
      inference: [/infer/i, /推理/],
      monitoring: [/monitor/i, /监控/]
    };

    function deriveCategories(it){
      const text = `${it.name||''} ${(it.summary||'')} ${(it.tags||[]).join(' ')}`;
      const cats = { capabilities: new Set(), scenes: new Set(), lifecycle: new Set() };
      const push = (k)=>{
        if (CANON.capabilities.includes(k)) cats.capabilities.add(k);
        else if (CANON.scenes.includes(k)) cats.scenes.add(k);
        else if (CANON.lifecycle.includes(k)) cats.lifecycle.add(k);
      };
      for(const [k, regs] of Object.entries(KEYWORDS)){
        if (regs.some(r=> r.test(text))) push(k);
      }
      return {
        capabilities: [...cats.capabilities],
        scenes: [...cats.scenes],
        lifecycle: [...cats.lifecycle]
      };
    }

    // Task label mapping from ai_categories.json
    let TASK_KEY_BY_LABEL = {};
    let TASK_LABELS_BY_KEY = {};
  let TASK_MATCHERS = [];
    function buildTaskMapFromCategories(tree){
      const keyByLabel = {};
      const labelsByKey = {};
      (tree||[]).forEach(c=> (c.subcategories||[]).forEach(s=> (s.tasks||[]).forEach(t=>{
        labelsByKey[t.key] = { zh: t.zh||'', en: t.en||'', es: t.es||'' };
        ['zh','en','es'].forEach(L=>{ const v = (t[L]||'').trim().toLowerCase(); if(v) keyByLabel[v] = t.key; });
      })));
      TASK_KEY_BY_LABEL = keyByLabel; TASK_LABELS_BY_KEY = labelsByKey;
    }
    function escRe(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
    function buildTaskMatchers(){
      // Core synonyms/abbreviations per task key
      const SYN = {
        // Vision
        image_classification: ['image classification','图像分类','clasificación de imágenes','imagenet','classifier'],
        object_detection: ['object detection','目标检测','detección de objetos','yolo','rcnn','retinanet'],
        semantic_segmentation: ['semantic segmentation','语义分割','segmentación semántica','segmentation model','deeplab'],
        instance_segmentation: ['instance segmentation','实例分割','segmentación de instancias','mask r-cnn','mask-rcnn','maskrcnn'],
        panoptic_segmentation: ['panoptic segmentation','全景分割','segmentación panóptica','panoptic'],
        text_to_image: ['text-to-image','文本生成图像','文生图','texto a imagen','stable diffusion','sdxl','diffusion','gan'],
        text_to_video: ['text-to-video','文本生成视频','文生视频','texto a video','video diffusion','sora'],
        nerf: ['nerf','神经辐射场','campos radiantes','instant-ngp'],
        super_resolution: ['super-resolution','超分辨','超分','superres','sr','esrgan','real-esrgan'],
        denoising: ['denoising','去噪','reducción de ruido','denoise','denoiser'],
        restoration: ['restoration','复原','restauración','deblurring','inpainting'],
  vqa: ['vqa','视觉问答','visual question answering'],
        visual_grounding: ['visual grounding','视觉定位','grounding','phrase grounding'],
  // keep lightweight but avoid overly generic matches by relying on boundaries later
  lightweight_visual_model: ['lightweight','轻量化','mobile','edge','tiny','nano'],
        // LLM & NLP
        llm_pretraining: ['pre-training','pretraining','预训练','preentrenamiento','language modeling'],
        instruction_tuning: ['instruction tuning','指令微调','指令学习','sft','supervised fine-tuning'],
        rlhf: ['rlhf','human feedback','人类反馈','pbrl','rm','reward model'],
        rag: ['rag','retrieval-augmented generation','检索增强生成','generación aumentada por recuperación'],
        code_generation: ['code generation','代码生成','generación de código','coder','codegen'],
  structured_reasoning: ['structured reasoning','结构化推理','razonamiento estructurado','tree of thoughts','graph of thoughts','chain of thought','cot'],
  tool_use: ['tool use','工具调用','uso de herramientas','agents','function calling','tool calling'],
  // drop overly generic 'adapter' to avoid false positives
  lora_adapter: ['lora','peft','low-rank','adalora','qlora'],
        multilingual_processing: ['multilingual','多语言','multilingüe','cross-lingual'],
        low_resource_language: ['low-resource language','低资源语言','pocos recursos','low resource'],
        knowledge_editing: ['knowledge editing','知识编辑','edición de conocimiento','knowledge injection'],
        nlp_data_synthesis: ['data synthesis','数据合成','síntesis de datos','synthetic data'],
        nlp_data_distillation: ['data distillation','数据蒸馏','destilación de datos'],
        dialogue_system_optimization: ['dialogue system','对话系统','sistema de diálogo','chatbot'],
        nlp_bias_mitigation: ['bias','偏见','sesgo','mitigation','harmful'],
        // Multimodal & Speech
        image_text_alignment: ['clip','图文对齐','image-text alignment'],
        multimodal_understanding_generation: ['multimodal','多模态','multimodal generation','gpt-4v','flamingo','llava'],
        asr: ['asr','automatic speech recognition','语音识别'],
        tts: ['tts','text-to-speech','语音合成'],
        slu: ['slu','spoken language understanding','语音理解'],
        speaker_separation: ['speaker separation','说话人分离','separación de hablantes'],
        noise_separation: ['noise separation','噪声分离','ruido ambiental'],
        full_duplex_dialogue: ['full-duplex','全双工'],
        avsr: ['avsr','audio-visual speech recognition','视听语音识别'],
        multimodal_dialogue_system: ['multimodal dialogue','多模态对话'],
        lightweight_multimodal_model: ['lightweight multimodal','多模态轻量化','edge multimodal'],
        // Graph / Recommendation / Retrieval
        gnn: ['gnn','graph neural network','图神经网络'],
        kg_construction: ['knowledge graph construction','知识图谱构建','construcción de grafos de conocimiento','kg build'],
        kg_reasoning: ['kg reasoning','知识图谱推理','razonamiento kg'],
  general_recommendation: ['recommendation system','推荐系统','recommender','reco'],
        vertical_recommendation: ['vertical recommendation','垂直推荐'],
        vector_retrieval: ['vector retrieval','向量检索','similarity search','faiss','ann','hnsw'],
        vector_db_optimization: ['vector database','向量数据库','milvus','weaviate','qdrant','chroma'],
        metric_learning: ['metric learning','度量学习'],
        contrastive_learning: ['contrastive learning','对比学习','cl'],
        ltr: ['learning to rank','学习排序','ltr'],
        neural_retrieval: ['neural retrieval','神经检索'],
        graph_augmented_reco: ['graph-augmented recommendation','图增强推荐'],
        // Optimization / System / Security
        model_compression: ['model compression','模型压缩','pruning','sparsity'],
  model_quantization: ['quantization','量化','int8','int4','quantize','gptq','awq'],
        model_distillation: ['distillation','蒸馏','knowledge distillation'],
        compilation_optimization: ['compilation optimization','编译优化','tvm','xla','triton'],
        inference_acceleration: ['inference acceleration','推理加速','vllm','tensorrt-llm','onnxruntime','openvino'],
        federated_learning: ['federated learning','联邦学习','fl'],
        privacy_computing: ['differential privacy','同态加密','差分隐私','homomorphic encryption','dp'],
  adversarial_attack: ['adversarial attack','对抗攻击'],
  adversarial_defense: ['adversarial defense','对抗防御'],
  red_teaming: ['red team','红队测试','red teaming'],
        content_moderation: ['content moderation','内容审查','moderación de contenidos'],
        auto_evaluation_models: ['evaluation model','评测模型','judge','arena','autoeval'],
        edge_hw_sw_co_design: ['edge ai hardware','硬件 软件 协同','硬软协同','co-design'],
        xai: ['xai','explainable ai','可解释'],
        ai_ethics_risk_assessment: ['ethics risk','伦理 风险','cumplimiento ético'],
        training_data_anonymization: ['anonymization','脱敏','anonimización'],
        training_data_copyright: ['copyright','版权'],
        model_monitoring: ['model monitoring','模型监控','monitorización de modelos'],
        model_iterative_update: ['iterative update','迭代 更新'],
        // Emerging / Temporal
        fluid_simulation: ['fluid simulation','流体模拟'],
        material_design: ['material design','材料 设计'],
        drug_molecule_prediction: ['drug','molecule','药物 分子'],
        robotic_vision: ['robotic vision','机器人 视觉'],
        robot_motion_planning: ['motion planning','运动 规划'],
        robot_environment_interaction: ['environment interaction','环境 交互'],
        molecular_generation: ['molecular generation','分子 生成'],
        bioinformatics_analysis: ['bioinformatics','生物 信息'],
        time_series_forecasting: ['time series forecasting','时间 序列 预测','ts forecasting'],
        time_series_anomaly_detection: ['time series anomaly detection','序列 异常 检测','ts anomaly'],
        radar_understanding: ['radar','雷达'],
        lidar_understanding: ['lidar','激光雷达','lidar data'],
        low_resource_medical_ai: ['low-resource medical ai','低资源 医疗'],
        low_resource_voice_assistant: ['low-resource voice assistant','低资源 语音 助手'],
        ar_vr_interaction: ['ar/vr','xr','虚拟 现实','增强 现实'],
        multimodal_temporal_fusion: ['multimodal temporal fusion','多模态 时序 融合'],
        robot_dialogue_logic: ['robot dialogue','机器人 对话']
      };
      const matchers = [];
      const ALLOWED_SHORTS = new Set(['ASR','TTS','SLU','RAG','GNN','XAI','NERF','AVSR','LTR','LORA']);
      for(const key of Object.keys(TASK_LABELS_BY_KEY)){
        const labels = TASK_LABELS_BY_KEY[key]||{};
        const pats = [];
        // exact label boundaries to avoid substring matches
        for(const L of ['zh','en','es']){
          const v = (labels[L]||'').trim();
          if(v){
            // Use word boundaries for latin labels, raw for CJK
            const isLatin = /[A-Za-z]/.test(v);
            pats.push(new RegExp(isLatin?`\\b${escRe(v.toLowerCase())}\\b`:escRe(v.toLowerCase()), 'i'));
          }
        }
        // curated aliases with safeguards: skip very short generic tokens (<4) unless whitelisted
        for(const aliasRaw of (SYN[key]||[])){
          const alias = aliasRaw.toLowerCase();
          const isLatin = /[A-Za-z]/.test(alias);
          const isShort = alias.replace(/[^A-Za-z0-9]/g,'').length < 4;
          if(isShort && !ALLOWED_SHORTS.has(alias.toUpperCase())) continue;
          const re = new RegExp(isLatin?`\\b${escRe(alias)}\\b`:escRe(alias), 'i');
          pats.push(re);
        }
        // common abbreviations (safe, with boundaries)
        const caps = key.toUpperCase();
        if(ALLOWED_SHORTS.has(caps)) pats.push(new RegExp(`\\b${escRe(caps)}\\b`, 'i'));
        matchers.push({ key, pats });
      }
      TASK_MATCHERS = matchers;
    }
    async function loadTaskMap(){
      const paths = [
        '../../data/ai/ai_categories.json',
        '/data/ai/ai_categories.json',
        '../data/ai/ai_categories.json',
        './data/ai/ai_categories.json'
      ];
      for(const p of paths){
        try{
          const res = await fetch(p,{cache:'no-store'}); if(!res.ok) continue;
          const txt = await res.text();
          try{
            const cj = JSON.parse(txt);
            if(cj?.categories){ buildTaskMapFromCategories(cj.categories); buildTaskMatchers(); return true; }
          }catch{}
        }catch{}
      }
      // even without file, keep empty matchers
      TASK_MATCHERS = [];
      return false;
    }
    function stdTagLabel(x){
      const raw = String(x||'');
      const rawTrim = raw.trim();
      const L = getLang();
      // If tag is exactly a known task key, map directly
      if(TASK_LABELS_BY_KEY[rawTrim]) return TASK_LABELS_BY_KEY[rawTrim][L] || rawTrim;
      const low = rawTrim.toLowerCase();
      const key = TASK_KEY_BY_LABEL[low]; if(!key) return raw;
      return TASK_LABELS_BY_KEY[key]?.[L] || raw;
    }

    function textOf(it){
      const fields = [it.id,it.name,it.url,it.summary,it.summary_en,it.summary_zh,it.summary_es].concat(it.tags||[]);
      return (fields.filter(Boolean).join(' ').toLowerCase());
    }
    function computeMatchedTaskKeys(it){
      const txt = textOf(it);
      const keys = new Set();
      // leverage existing tags mapping if any
      (it.tags||[]).forEach(tag=>{
        const low = String(tag||'').trim().toLowerCase();
        const k = TASK_KEY_BY_LABEL[low]; if(k) keys.add(k);
      });
      // run matchers
      for(const m of TASK_MATCHERS){
        if(m.pats.some(p=> p.test(txt))){ keys.add(m.key); }
      }
      return [...keys];
    }
    function labelsFromTaskKeys(keys){
      const L = getLang();
      const out = [];
      const seen = new Set();
      for(const k of keys){ const v = TASK_LABELS_BY_KEY[k]?.[L]; if(v && !seen.has(v)){ seen.add(v); out.push(v); } }
      return out.slice(0,6);
    }

    function pickSummary(it){
      const lang = getLang();
      // Prefer language-specific summary, but gracefully fall back to any available summary
      if(!it) return '';
      if(lang==='zh') return it.summary_zh || it.summary || it.summary_en || it.summary_es || '';
      if(lang==='es') return it.summary_es || it.summary || it.summary_en || it.summary_zh || '';
      // en
      return it.summary_en || it.summary || it.summary_zh || it.summary_es || '';
    }

    function card(it){
      const src = it.source==='github'?'GitHub':'HF';
  // tags will be computed after task badges so we can filter out duplicates
  let tags = '';
      const metrics = (function(){
        const p=[];
        if(it.source==='github') p.push(`★ ${(it.stats?.stars||0)}`); else p.push(`⬇︎ ${(it.stats?.downloads_total||0)}`);
        if(it.stats?.forks) p.push(`⑂ ${it.stats.forks}`);
        if(it.stats?.likes_total) p.push(`❤ ${(it.stats?.likes_total)}`);
        if(it.stats?.stars_7d) p.push(`★7d ${it.stats.stars_7d}`);
        if(it.stats?.forks_7d) p.push(`⑂7d ${it.stats.forks_7d}`);
        if(it.stats?.downloads_7d) p.push(`⬇︎7d ${(it.stats?.downloads_7d)}`);
        if(it.stats?.likes_7d) p.push(`❤7d ${(it.stats?.likes_7d)}`);
        if(it.score_model) p.push(`S ${Number(it.score_model).toFixed(2)}`);
        if(it.score_engineering) p.push(`S ${Number(it.score_engineering).toFixed(2)}`);
        return p.join(' · ');
      })();
      const last = it.updated_at?` · ${rel(it.updated_at)}`:'';
      const color = getComputedStyle(document.documentElement).getPropertyValue('--secondary')||'#0ea5e9';
      const tms = (it.timeline?.t||[]).map(x=>Date.parse(x));
      const starSeries = it.timeline?.stars || [];
      const dlSeries = it.timeline?.downloads || [];
      const series = (src==='GitHub') ? starSeries : dlSeries;
      const sgv = sparkline(tms, series, color);
      const url = it.url || (src==='GitHub'?`https://github.com/${esc(it.id)}`:`https://huggingface.co/${esc(it.id)}`);
      const lang = getLang();
      let sum = pickSummary(it);
      // fallback logic + missing indicator
      if(!sum){
        // Try neutral summary
        sum = it.summary || it.description || '';
        if(sum){
          // Provide indicator that translation missing
          let indicator='';
          if(lang==='zh') indicator='（暂无中文摘要，显示通用/英文）';
          else if(lang==='es') indicator='(Sin resumen en español, mostrando general/inglés)';
          else indicator='(No localized summary)';
          sum = indicator + ' ' + sum;
        }
      }
      // Reason badge translation
      function reasonLabel(key){
        if(!key) return '';
  const lang = getLang();
        const mapKey = 'mw_reason_'+key.replace(/[^a-z0-9_]/g,'');
        return (window.translations?.[lang]?.[mapKey]) || key;
      }
      // Task badge translation with fallbacks (meta -> translations -> en -> zh -> key)
      function taskLabel(key, lang){
        const meta = (TASK_LABELS_BY_KEY && TASK_LABELS_BY_KEY[key]) || {};
        // Direct meta match for current language
        if(meta[lang]) return meta[lang];
        // Look for explicit translation dictionary entry e.g. mw_task_<key>
        const tKey = 'mw_task_'+key.replace(/[^a-z0-9_]/g,'');
        const trans = window.translations?.[lang]?.[tKey];
        if(trans) return trans;
        // Fall back priority: English meta (if different), then Chinese, then any non-empty, finally raw key
        if(lang !== 'en' && meta.en) return meta.en;
        if(meta.zh) return meta.zh;
        if(meta.es) return meta.es; // last resort other locale
        return meta.en || key;
      }
      const reason = it.reason_label ? `<span class="mw-badge" data-type="reason" title="${esc(it.reason_text||'')}">${esc(reasonLabel(it.reason_label))}</span>` : '';
      // Per-task badges: always show task list if task_keys present. Replace generic Multi badge.
      let multi = '';
      try{
        if(Array.isArray(it.task_keys) && it.task_keys.length){
          const lang = getLang();
          const maxShow = 3;
          const tkAll = it.task_keys;
          const shown = tkAll.slice(0,maxShow);
          const hidden = tkAll.length - shown.length;
          const labelMap = TASK_LABELS_BY_KEY || {};
          multi = shown.map(k=>{
            const txt = taskLabel(k, lang);
            return `<span class=\"mw-badge\" data-type=\"multi\" title=\"${esc(k)}\">${esc(txt)}</span>`;
          }).join('');
          if(hidden>0){
            multi += `<span class=\"mw-badge\" data-type=\"multi\" title=\"${esc(tkAll.join(', '))}\">+${hidden}</span>`;
          }
          if(multi) multi = `<div class=\"mw-badges\">${multi}</div>`;
        }
      }catch{}
      const badges = (reason||multi)? `<div class=\"mw-badges\">${reason}${multi}</div>` : '';
      // Build tag chips now that task badges (multi) were computed. Filter out any
      // tag label that matches a task badge label (language-aware) to avoid
      // duplicated labels appearing both as badges and as tag chips.
      try{
        const rawTags = Array.isArray(it.tags) ? (it.tags||[]).slice(0,6) : [];
        const taskLabelSet = new Set();
        if(Array.isArray(it.task_keys) && it.task_keys.length){
          const _lang = getLang();
          for(const k of it.task_keys){
            try{ taskLabelSet.add((taskLabel(k, _lang)||'').toString().trim().toLowerCase()); }catch{}
          }
        }
        const filtered = rawTags.filter(t=> !taskLabelSet.has((t||'').toString().trim().toLowerCase()));
        tags = filtered.map(x=>`<span class="tag">${esc(x)}</span>`).join(' ');
      }catch{}

      const dk = (it.task_keys && it.task_keys.length) ? esc((it.task_keys||[]).join(' ')) : '';
      return `<article class="card mw-card" data-id="${esc(it.id)}" data-task-keys="${dk}">
        <h4 class="mw-title"><a href="${esc(url)}" target="_blank" rel="noopener noreferrer">${esc(it.name||it.id)}</a></h4>
        <div class="mw-meta">${src} · ${metrics}${last}</div>
        ${badges}
        <div class="mw-tags">${tags}</div>
        <div>${sgv}</div>
        ${sum?`<p class=\"muted\" style=\"margin:.5rem 0 0 0; line-height:1.4\">${esc(sum)}</p>`:''}
      </article>`;
    }

    // Build searchable text and score by query tokens
    function buildSearchIndex(it){
      const lang = getLang();
      const summaryLang = lang==='zh'? it.summary_zh : lang==='es'? it.summary_es : it.summary_en;
      const parts = [it.id,it.name,it.source,summaryLang,it.summary,it.summary_en,it.summary_zh,it.summary_es].concat(it.tags||[]);
      return parts.filter(Boolean).join(' ').toLowerCase();
    }
    function scoreItem(it, tokens){
      if(!tokens.length) return 0;
      let score = 0;
      const text = buildSearchIndex(it);
      for(const tk of tokens){
        const idx = text.indexOf(tk);
        if(idx>=0){
          // proximity + early boost
          score += 10;
          if(idx<40) score += 4;
          if(/\b/.test(tk)) score += 2;
        }
      }
      // small boost for more matching tags
      const tg = (it.tags||[]).join(' ').toLowerCase();
      for(const tk of tokens){ if(tg.includes(tk)) score+=3; }
      // Apply recent-repeat penalty when available
      try{
        const k = normalizeKey(it);
        if(_recentIdSet && k && _recentIdSet.has(k)) score -= RECENT_REPEAT_PENALTY;
      }catch{}
      return score;
    }
    function highlightText(html, tokens){
      if(!tokens.length) return html;
      try{
        const escaped = tokens.map(t=> t.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'));
        if(!escaped.length) return html;
        const re = new RegExp('('+escaped.join('|')+')','ig');
        return html.replace(re, m=>`<span class="mw-highlight">${m}</span>`);
      }catch{return html;}
    }
    function filterSort(arr){
      // 1) Defensive de-duplication (source + id/url/name as stable key)
      const seen = new Set();
      let out = [];
      for(const it of arr){
        // Skip placeholder/invalid entries produced upstream
        try{ if(it && it.flags && it.flags.placeholder) continue; }catch{}
        // prefer normalized key for cross-source dedupe; fall back to source-prefixed raw id
        const nk = normalizeKey(it);
        const key = nk ? `norm::${nk}` : `${it.source||''}::${it.id||it.url||it.name||''}`;
        if(seen.has(key)) continue; seen.add(key); out.push(it);
      }
  // no model-id exact filter (covered by search)
      // search
      const qs = (query||'').trim().toLowerCase();
      if(qs){
        const rawTokens = qs.split(/\s+/).filter(Boolean);
        // allow simple partial tokens by also trying original string
        out = out.filter(it =>{
          const text = buildSearchIndex(it);
          if(text.includes(qs)) return true;
          return rawTokens.every(tk => text.includes(tk));
        });
      }
      // sort
      const key = sortEl.value||'score';
      if(qs){
        const tokens = qs.split(/\s+/).filter(Boolean);
        out.forEach(o=>{ o.__qScore = scoreItem(o, tokens); });
        out.sort((a,b)=> b.__qScore - a.__qScore);
      } else {
        out.sort((a,b)=>{
          if(key==='delta7'){
            const av = (a.stats?.stars_7d ?? a.stats?.downloads_7d ?? 0);
            const bv = (b.stats?.stars_7d ?? b.stats?.downloads_7d ?? 0);
            return bv - av;
          }
          if(key==='stars') return (b.stats?.stars||0) - (a.stats?.stars||0);
          if(key==='downloads') return (b.stats?.downloads_total||0) - (a.stats?.downloads_total||0);
          if(key==='stars7') return (b.stats?.stars_7d||0) - (a.stats?.stars_7d||0);
          if(key==='forks7') return (b.stats?.forks_7d||0) - (a.stats?.forks_7d||0);
          if(key==='downloads7') return (b.stats?.downloads_7d||0) - (a.stats?.downloads_7d||0);
          if(key==='likes7') return (b.stats?.likes_7d||0) - (a.stats?.likes_7d||0);
          // Base values
          const va = (a.score||a.score_model||a.score_engineering||0);
          const vb = (b.score||b.score_model||b.score_engineering||0);
          // Apply recent penalty if exactly one item was seen in the recent window
          try{
            if(_recentIdSet){
              const ka = normalizeKey(a);
              const kb = normalizeKey(b);
              const ra = ka && _recentIdSet.has(ka);
              const rb = kb && _recentIdSet.has(kb);
              if(ra && !rb) return (vb - va) + RECENT_REPEAT_PENALTY;
              if(rb && !ra) return (vb - va) - RECENT_REPEAT_PENALTY;
              // if both recent or both not recent -> fallthrough to base compare
            }
          }catch{}
          return vb - va;
        });
      }
      return out;
    }

    function render(){
      // Determine current mode using window.__mw_mode_current if present, else fallback to MODE
      const currentMode = (window.__mw_mode_current || MODE || '').toString().trim();
  // Base array: optionally use itemsAll (all dates) when toggle enabled and loaded.
  // Support both daily and hf modes for cross-date filtering when the prebuilt
  // aggregation is available (itemsAll populated by loadAllDaily or loadAllHF).
  const applyAllDates = useAllDatesForFilter && itemsAll && itemsAll.length;
  let baseArr = (applyAllDates && (currentMode === 'daily' || currentMode === 'hf')) ? itemsAll : items;
  let arr = filterSort(baseArr);
  // Data-layer filtering: when tasks selected, filter the array itself for HF (and for Daily when global mode active)
  try{
    if(selectedTasks && selectedTasks.size>0){
      const curMode = currentMode;
      const applyAtData = (curMode === 'hf') || (curMode === 'daily' && typeof isGlobalActive === 'function' && isGlobalActive());
      if(applyAtData){
        arr = arr.filter(it => {
          try{
            const keys = (it.task_keys && it.task_keys.length) ? it.task_keys : computeMatchedTaskKeys(it);
            for(const k of keys || []){ if(selectedTasks.has(k)) return true; }
          }catch{}
          return false;
        });
      }
    }
  }catch{}
  // Compute per-task counts from the final array so the cascader UI can show only
  // categories/tasks that have matched items after filtering. Expose as a simple
  // lookup on window for the cascader render helpers to consult.
  try{
    const counts = {};
    for(const it of arr || []){
      try{
        if(Array.isArray(it.task_keys)){
          for(const k of it.task_keys){ counts[k] = (counts[k]||0) + 1; }
        }
      }catch{}
    }
    window.__mw_task_counts = counts;
  }catch{ window.__mw_task_counts = {}; }
      // No per-category filtering for GH mode — GH shows full hotlist. HF mode filtering is applied via applyFilter (task selection).
  const dt = window.__mw_updated_at || '';
  const lang = localStorage.getItem('lang')||document.documentElement.lang||'zh';
      // Removed explicit updated-at display per user request
      let modeLabel = MODE==='daily'? (window.translations?.[lang]?.mw_mode_daily || 'Daily Picks') : MODE==='gh'? (window.translations?.[lang]?.mw_mode_gh_top || 'GitHub Top') : (window.translations?.[lang]?.mw_mode_hf_top || 'HF Top');
        if(isGlobalActive()){
        subEl.hidden = true;
      }else{
        subEl.hidden = false;
        const allSuffix = useAllDatesForFilter? (lang==='zh'? ' · (跨历史)' : lang==='es'? ' · (Todas fechas)' : ' · (All dates)') : '';
        if (lang==='en') subEl.textContent = `${modeLabel} · Items ${arr.length}${allSuffix}`;
        else if (lang==='es') subEl.textContent = `${modeLabel} · Elementos ${arr.length}${allSuffix}`;
        else subEl.textContent = `${modeLabel} · 共 ${arr.length} 项${allSuffix}`;
      }

      // Disable/hide irrelevant sort options per mode (hide by disabling + style)
      const hideMatrix = {
        gh: new Set(['downloads','downloads7','likes7']),
        hf: new Set(['stars','stars7','forks7']),
        daily: new Set(['forks7','downloads','downloads7','likes7','stars7'])
      };
      const hide = hideMatrix[MODE]||new Set();
      for(const opt of sortEl.options){
        const shouldHide = hide.has(opt.value);
        opt.disabled = shouldHide;
        opt.hidden = shouldHide;
      }
      // If current sort now hidden -> fallback to score
      if(sortEl.selectedOptions[0]?.hidden){ sortEl.value='score'; }
      updateClearButtonVisibility();

      // no datalist population

      // Render content
      if (MODE==='daily'){
        if(isGlobalActive()){
          gridEl.classList.add('mw-grid');
          const arrG = filterSort(itemsAll);
          gridEl.innerHTML = arrG.map(card).join('');
        }else{
          // Render two full-width sections: GitHub first, then a divider, then HF
          gridEl.classList.remove('mw-grid');
          const gh = arr.filter(x=>x.source==='github');
          const hf = arr.filter(x=>x.source!=='github');
          const ghTitle = t('mw_section_gh', 'GitHub 开源项目');
          const hfTitle = t('mw_section_hf', 'Hugging Face 开源模型');
          const ghHtml = gh.length? `<div class="mw-sec-title">${esc(ghTitle)} · ${gh.length}</div><div class="mw-grid">${gh.map(card).join('')}</div>` : '';
          const sep = (gh.length && hf.length)? `<hr class="mw-sec-sep"/>` : '';
          const hfHtml = hf.length? `<div class="mw-sec-title">${esc(hfTitle)} · ${hf.length}</div><div class="mw-grid">${hf.map(card).join('')}</div>` : '';
          gridEl.innerHTML = ghHtml + sep + hfHtml;
        }
      }else{
        // Hotlist grouping (engineering or model lab) when hotlist structure present
        const grouping = window.__mw_hot_grouping;
        if(grouping && arr.some(it=>it.__group)){
          gridEl.classList.remove('mw-grid');
          const order = [];
          const bucket = {};
          for(const it of arr){ const g=it.__group||'other'; if(!bucket[g]){ bucket[g]=[]; order.push(g);} bucket[g].push(it); }
          const lang2 = getLang();
          function labelForGroup(k){ return TAG_LABELS?.[lang2]?.[k] || k; }
          const sections = [];
          for(const k of order){
            let list = filterSort(bucket[k]);
            // Skip empty groups after any data-layer filtering so only relevant
            // categories are shown when a task filter is active.
            if(!list || list.length===0) continue;
            sections.push(`<details open data-group="${esc(k)}" class="mw-hot-group"><summary style="cursor:pointer;font-weight:600;margin:12px 0 6px;color:var(--secondary)">${esc(labelForGroup(k))} · ${list.length}</summary><div class="mw-grid">${list.map(card).join('')}</div></details>`);
          }
          gridEl.innerHTML = sections.join('');
          try{ cleanEmptyGroups(); }catch{}
          // Group summaries are non-interactive in this build; keep sections static
        }else{
          gridEl.classList.add('mw-grid');
            gridEl.innerHTML = arr.map(card).join('');
        }
      }
      // No post-render GH category enforcement in this build.
    }

    // Extend existing mode switching (modesEl listener defined earlier in file) by observing MODE changes
    const origSetMode = (function(){ return null; })(); // placeholder to avoid ref errors
    // Mutation observer pattern not needed; just patch after initial event binding
    (function hookModeButtons(){
      try{
        const modesEl = document.getElementById('mw-modes');
        if(!modesEl) return;
        modesEl.addEventListener('click', (e)=>{
          const btn = e.target.closest('button[data-mode]'); if(!btn) return;
          const mode = btn.getAttribute('data-mode');
          window.__mw_mode_current = mode; // expose
          try{ setTriggerLabelForMode(mode); }catch{}
          try{ showCascaderTriggerForMode(mode); }catch{}
        });
        // initial label & visibility
        setTriggerLabelForMode(MODE);
        try{ showCascaderTriggerForMode(MODE); }catch{}
      }catch{}
    })();

    async function loadCategories(){
      try{
        const cj = await fetch('../../data/ai/modelswatch/categories.json',{cache:'no-store'}).then(r=>r.json());
        if(cj?.categories) CANON = cj.categories;
        if(cj?.labels) TAG_LABELS = cj.labels;
        rebuildLabelIndex();
        catsLoaded = true;
      }catch{ catsLoaded = false; }
    }

    async function loadDaily(dateStr){
      try{
        if(dateStr){
          // load combined archive for the specified date
          const d = await fetch(`../../data/ai/modelswatch/daily/${dateStr}.json`,{cache:'no-store'}).then(r=>r.json());
            const arr = (d?.items||[]).map(shallowNormalize);
            items = arr;
            window.__mw_updated_at = computeUpdatedAt(d?.updated_at, arr, dateStr);
            try{ setDataSourceLabel('Daily', dateStr||'archive'); }catch{}
        }else{
          const [g,h] = await Promise.all([
            fetch('../../data/ai/modelswatch/daily_github.json',{cache:'no-store'}).then(r=>r.json()),
            fetch('../../data/ai/modelswatch/daily_hf.json',{cache:'no-store'}).then(r=>r.json()),
          ]);
          const gi = (g?.items||[]).map(shallowNormalize);
          const hi = (h?.items||[]).map(shallowNormalize);
          // merge + dedupe (prefer normalized key)
          const seen = new Set(); const merged=[];
          for(const it of [...gi, ...hi]){ const nk = normalizeKey(it); const k = nk ? `norm::${nk}` : `${it.source||''}::${it.id||it.url||it.name||''}`; if(seen.has(k)) continue; seen.add(k); merged.push(it); }
          items = merged;
          // choose the newer meta among g/h
          const gIso = toIso(g?.updated_at);
          const hIso = toIso(h?.updated_at);
          const newerMeta = (gIso && hIso) ? (gIso>hIso?gIso:hIso) : (gIso || hIso || '');
          window.__mw_updated_at = computeUpdatedAt(newerMeta, merged);
          try{ setDataSourceLabel('Daily', newerMeta||'merged'); }catch{}
        }
      }catch{ items=[]; window.__mw_updated_at=''; }
    }

    // Populate the date control (replace input value list) so only availableDates are selectable
    function populateDateControl(){
      try{
        // if availableDates empty leave the native date input
        if(!Array.isArray(availableDates) || availableDates.length===0) return;
        // If browser supports datalist we can keep input but restrict; simpler: replace with <select>
        const parent = dateInput.parentElement;
        if(!parent) return;
        // create select if not already
        if(dateInput.tagName.toLowerCase()==='select') return; // already replaced
        const sel = document.createElement('select'); sel.id = 'mw-date'; sel.className = 'input';
        availableDates.slice().reverse().forEach(d=>{ const opt = document.createElement('option'); opt.value=d; opt.textContent=d; sel.appendChild(opt); });
        // replace node
        parent.replaceChild(sel, dateInput);
        // rebind controls
        dateInput = document.getElementById('mw-date');
        dateInput.addEventListener('change', async ()=>{
          const v = dateInput.value;
          selectedDate = (v && availableDates.includes(v)) ? v : '';
          await loadDaily(selectedDate);
          setGlobalActive(false);
          render();
        });
      }catch{}
    }

    async function loadTopGH(){
      // Use snapshot sidecar as authoritative source when available (B option)
      try{
        const snapDate = await latestSnapshotDate();
        if(snapDate){
          try{
            const ghPath = `../../data/ai/modelswatch/snapshots/${snapDate}/gh_summaries.json`;
            const snap = await fetch(ghPath,{cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null);
            if(snap?.items){
              // detect placeholder-heavy snapshots generated when LLM unavailable
              const total = snap.items.length;
              const ph = (snap.items||[]).filter(it=>{
                const s = (it.summary||it.summary_zh||it.summary_en||'').toString();
                return /自动摘要（占位|占位:无法连接|占位:空响应|placeholder/i.test(s);
              }).length;
              const phRatio = total? (ph/total) : 0;
              if(phRatio <= 0.5){
                const arr = (snap.items||[]).map(it=> shallowNormalize({...it, __hot:'projects'}));
                items = arr;
                window.__mw_hot_grouping = 'projects';
                window.__mw_updated_at = computeUpdatedAt(snap?.updated_at || snap?.generated_at, arr);
                try{ setDataSourceLabel('Snapshot', snapDate); }catch{}
                // snapshot loaded
                return;
              } else {
                console.warn('[mw] snapshot', snapDate, 'appears placeholder-heavy (ratio=' + phRatio.toFixed(2) + '), skipping');
              }
            }
          }catch{}
        }
      }catch{}
      // Fallback: prefer engineering hotlist if snapshot missing or skipped
      try{
        const hot = await fetch('../../data/ai/modelswatch/projects_hotlist.json',{cache:'no-store'}).then(r=>r.json());
        if(hot?.by_category){
          if(typeof hot.version==='number' && hot.version!==1){ console.warn('[mw] projects_hotlist version mismatch', hot.version); }
          const out=[]; const multiCount={};
          for(const [cat,list] of Object.entries(hot.by_category)){
            (list||[]).forEach(it=>{ out.push(shallowNormalize({...it,__group:cat,__hot:'projects'})); multiCount[it.id]=(multiCount[it.id]||0)+1; });
          }
          out.forEach(o=>{ if(multiCount[o.id]>1) o.__multi=true; });
          items = out; window.__mw_hot_grouping='projects';
          window.__mw_updated_at = computeUpdatedAt(hot?.updated_at, out);
          try{ setDataSourceLabel('Hotlist', 'projects_hotlist.json'); }catch{}
          // hotlist loaded
          return;
        }
      }catch(e){ /* fallback */ }
      // Last resort: top_github with best-effort enrichment from snapshot if present
      try{
        const g = await fetch('../../data/ai/modelswatch/top_github.json',{cache:'no-store'}).then(r=>r.json());
        let arr = (g?.items||[]).map(shallowNormalize);
        try{
          const snapDate = await latestSnapshotDate();
          if(snapDate){
            const ghPath = `../../data/ai/modelswatch/snapshots/${snapDate}/gh_summaries.json`;
            const snap = await fetch(ghPath,{cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null);
            if(snap?.items){
              const map = new Map();
              snap.items.forEach(it=> map.set(it.id, it));
              arr = arr.map(it=>{
                const m = map.get(it.id);
                if(m){
                  return { ...it,
                    summary: m.summary || it.summary || '',
                    summary_en: m.summary_en || it.summary_en || it.summary || '',
                    summary_zh: m.summary_zh || it.summary_zh || '',
                    summary_es: m.summary_es || it.summary_es || ''
                  };
                }
                return it;
              });
            }
          }
        }catch{}
  items = arr; window.__mw_hot_grouping='';
  window.__mw_updated_at = computeUpdatedAt(g?.updated_at, arr);
  try{ setDataSourceLabel('Top List', 'top_github.json'); }catch{}
  // top_github fallback loaded
      }catch{ items=[]; window.__mw_updated_at=''; window.__mw_hot_grouping=''; }
    }

    async function loadTopHF(){
      // Use snapshot sidecar as authoritative source when available (B option)
      try{
        const snapDate = await latestSnapshotDate();
        if(snapDate){
          try{
            const hfPath = `../../data/ai/modelswatch/snapshots/${snapDate}/hf_summaries.json`;
            const snap = await fetch(hfPath,{cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null);
            if(snap?.items){
              // detect placeholder-heavy snapshots generated when LLM unavailable
              const total = snap.items.length;
              const ph = (snap.items||[]).filter(it=>{
                const s = (it.summary||it.summary_zh||it.summary_en||'').toString();
                return /自动摘要（占位|占位:无法连接|占位:空响应|placeholder/i.test(s);
              }).length;
              const phRatio = total? (ph/total) : 0;
              if(phRatio <= 0.5){
                const arr = (snap.items||[]).map(it=> shallowNormalize({...it, __hot:'models'}));
                items = arr;
                window.__mw_hot_grouping = 'models';
                window.__mw_updated_at = computeUpdatedAt(snap?.updated_at || snap?.generated_at, arr);
                try{ setDataSourceLabel('Snapshot', snapDate); }catch{}
                return;
              } else {
                console.warn('[mw] snapshot', snapDate, 'appears placeholder-heavy (ratio=' + phRatio.toFixed(2) + '), skipping');
              }
            }
          }catch{}
        }
      }catch{}
      // Fallback: prefer models hotlist if snapshot missing or skipped
      try{
        const hot = await fetch('../../data/ai/modelswatch/models_hotlist.json',{cache:'no-store'}).then(r=>r.json());
        if(hot?.by_category){
          if(typeof hot.version==='number' && hot.version!==1){ console.warn('[mw] models_hotlist version mismatch', hot.version); }
          const out=[]; const multiCount={};
          for(const [task,list] of Object.entries(hot.by_category)){
            (list||[]).forEach(it=>{ out.push(shallowNormalize({...it,__group:task,__hot:'models'})); multiCount[it.id]=(multiCount[it.id]||0)+1; });
          }
          out.forEach(o=>{ if(multiCount[o.id]>1) o.__multi=true; });
          items = out; window.__mw_hot_grouping='models';
          window.__mw_updated_at = computeUpdatedAt(hot?.updated_at, out);
          try{ setDataSourceLabel('Hotlist', 'models_hotlist.json'); }catch{}
          return;
        }
      }catch(e){ /* fallback */ }
      // Last resort: top_hf with best-effort enrichment from snapshot if present
      try{
        const h = await fetch('../../data/ai/modelswatch/top_hf.json',{cache:'no-store'}).then(r=>r.json());
        let arr = (h?.items||[]).map(shallowNormalize);
        try{
          const snapDate = await latestSnapshotDate();
          if(snapDate){
            const hfPath = `../../data/ai/modelswatch/snapshots/${snapDate}/hf_summaries.json`;
            const snap = await fetch(hfPath,{cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null);
            if(snap?.items){
              const map = new Map();
              snap.items.forEach(it=> map.set(it.id, it));
              arr = arr.map(it=>{
                const m = map.get(it.id);
                if(m){
                  return { ...it,
                    summary: m.summary || it.summary || '',
                    summary_en: m.summary_en || it.summary_en || it.summary || '',
                    summary_zh: m.summary_zh || it.summary_zh || '',
                    summary_es: m.summary_es || it.summary_es || ''
                  };
                }
                return it;
              });
            }
          }
        }catch{}
  items = arr; window.__mw_hot_grouping='';
  window.__mw_updated_at = computeUpdatedAt(h?.updated_at, arr);
  try{ setDataSourceLabel('Top List', 'top_hf.json'); }catch{}
      }catch{ items=[]; window.__mw_updated_at=''; window.__mw_hot_grouping=''; }
    }

    // loadAllDaily optionally accepts a progress callback(progressCount, total)
    async function loadAllDaily(progressCb){
      if(allLoaded) return;
      try{
        if(availableDates.length===0){
          try{ availableDates = await fetch('../../data/ai/modelswatch/daily/dates.json',{cache:'no-store'}).then(r=>r.json()); }
          catch{ availableDates = []; }
          try{ populateDateControl(); }catch{}
        }
        const seen = new Set(); const merged = [];
        const chunk = 6;
        let loadedCount = 0;
        const total = availableDates.length || 0;
        for(let i=0;i<availableDates.length;i+=chunk){
          const batch = availableDates.slice(i,i+chunk);
          const res = await Promise.allSettled(batch.map(d=> fetch(`../../data/ai/modelswatch/daily/${d}.json`,{cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null)));
          for(const r of res){
            if(r.status==='fulfilled' && r.value){
              const arr = (r.value?.items||[]).map(shallowNormalize);
              for(const it of arr){ const nk = normalizeKey(it); const k = nk ? `norm::${nk}` : `${it.source||''}::${it.id||it.url||it.name||''}`; if(seen.has(k)) continue; seen.add(k); merged.push(it); }
            }
            loadedCount++;
            try{ if(typeof progressCb === 'function') progressCb(loadedCount, total); }catch{}
          }
        }
        itemsAll = merged; allLoaded = true;
      }catch{ itemsAll = []; allLoaded = false; }
    }

    // Load prebuilt HF aggregation (produced by CI) to enable cross-date HF search
    async function loadAllHF(progressCb){
      try{
        const base = '../../data/ai/modelswatch';
        const allPath = `${base}/all_dates_hf.json`;
        const countsPath = `${base}/task_counts_history.json`;
        // fetch counts first (small)
        try{
          const r = await fetch(countsPath,{cache:'no-store'});
          if(r.ok){ const j = await r.json(); window.__mw_task_counts = j.counts || {}; }
        }catch(e){ /* ignore, will compute later if missing */ }
        // fetch aggregated items (may be larger)
        const r2 = await fetch(allPath,{cache:'no-store'});
        if(!r2.ok) { itemsAll = []; allLoaded = false; return false; }
        const j2 = await r2.json();
        const arr = (j2?.items||[]).map(shallowNormalize);
        itemsAll = arr; allLoaded = true;
        // recompute counts if not provided
        if(!window.__mw_task_counts || Object.keys(window.__mw_task_counts).length===0){
          const counts = {};
          for(const it of itemsAll || []){ if(Array.isArray(it.task_keys)) for(const k of it.task_keys) counts[k] = (counts[k]||0)+1; }
          window.__mw_task_counts = counts;
        }
        return true;
      }catch(e){ console.warn('[mw] loadAllHF error', e); itemsAll = []; allLoaded = false; return false; }
    }

    // Resolve latest snapshot date: pointer file -> recent probe -> today fallback
    async function latestSnapshotDate(){
      try{ const r = await fetch('../../data/ai/modelswatch/latest_snapshot.json',{cache:'no-store'}); if(r.ok){ const j = await r.json(); if(j?.latest) return j.latest; } }catch{}
      const dates = candidateRecentDates(5);
      for(const d of dates){
        try{ const head = await fetch(`../../data/ai/modelswatch/snapshots/${d}/hf_summaries.json`,{method:'HEAD'}); if(head.ok) return d; }catch{}
      }
      return new Date().toISOString().slice(0,10);
    }
    // Update the small data-source badge in the toolbar. kind is one of: 'Snapshot','Hotlist','Top List','Daily'
    function setDataSourceLabel(kind, hint){
      try{
        const el = document.getElementById('mw-datasource');
        if(!el) return;
        const tag = el.querySelector('.mw-ds-tag');
        const label = el.querySelector('.mw-ds-label');
        const lang = (typeof getLang === 'function') ? getLang() : 'en';
        let disp = '';
        if(kind === 'Snapshot'){
          if(lang==='zh') disp = `快照：${hint || ''}`;
          else if(lang==='es') disp = `Snapshot: ${hint || ''}`;
          else disp = `Snapshot · ${hint || ''}`;
        }else if(kind === 'Hotlist'){
          if(lang==='zh') disp = `热表：${hint || ''}`;
          else if(lang==='es') disp = `Hotlist · ${hint || ''}`;
          else disp = `Hotlist · ${hint || ''}`;
        }else if(kind === 'Top List'){
          if(lang==='zh') disp = `榜单：${hint || ''}`;
          else if(lang==='es') disp = `Top · ${hint || ''}`;
          else disp = `Top List · ${hint || ''}`;
        }else if(kind === 'Daily'){
          if(lang==='zh') disp = `今日灵感：${hint || ''}`;
          else if(lang==='es') disp = `Daily · ${hint || ''}`;
          else disp = `Daily · ${hint || ''}`;
        }else{
          disp = (hint? `${kind} · ${hint}` : kind);
        }
        if(tag) tag.textContent = 'DS';
          if(label) label.textContent = disp;
        el.style.display = '';
      }catch{}
    }
    // Try to load snapshot sidecar for a given date and mode ('gh' or 'hf').
    // Returns true if snapshot loaded successfully and items updated.
  let snapshotLastCount = 0;
    async function loadSnapshotForMode(dateStr, mode){
      try{
        if(!dateStr) return false;
        let rel = '';
        let grouping = '';
        if(mode==='gh'){
          rel = `../../data/ai/modelswatch/snapshots/${dateStr}/gh_summaries.json`;
          grouping = 'projects';
        }else if(mode==='hf'){
          rel = `../../data/ai/modelswatch/snapshots/${dateStr}/hf_summaries.json`;
          grouping = 'models';
        }else{
          return false;
        }
        const snap = await fetch(rel, {cache:'no-store'}).then(r=> r.ok? r.json(): null).catch(()=>null);
  if(!snap || !Array.isArray(snap.items) || snap.items.length===0) return false;
        // basic placeholder-safety: ensure not dominated by placeholder summaries
        const total = snap.items.length;
        const ph = (snap.items||[]).filter(it=>{
          const s = (it.summary||it.summary_zh||it.summary_en||'').toString();
          return /自动摘要（占位|占位:无法连接|占位:空响应|placeholder/i.test(s);
        }).length;
        const phRatio = total? (ph/total) : 0;
        if(phRatio > 0.9){
          console.warn('[mw] snapshot', dateStr, 'looks placeholder-heavy (ratio=', phRatio.toFixed(2), '), refusing to load');
          return false;
        }
  const arr = (snap.items||[]).map(it=> shallowNormalize({...it, __hot: grouping}));
  items = arr;
  snapshotLastCount = Array.isArray(snap.items) ? snap.items.length : (arr.length||0);
  window.__mw_hot_grouping = grouping;
  window.__mw_updated_at = computeUpdatedAt(snap?.updated_at || snap?.generated_at, arr);
  try{ setDataSourceLabel('Snapshot', dateStr); }catch{}
  return true;
      }catch(e){ console.warn('[mw] loadSnapshotForMode error', e); return false; }
    }
    function candidateRecentDates(n){
      const out=[]; const now = new Date();
      for(let i=0;i<n;i++){ const d = new Date(now.getTime()-i*86400000); out.push(d.toISOString().slice(0,10)); }
      return out;
    }

    function shallowNormalize(it){
      const id = it.id || it.repo_id || it.url || it.name;
      const source = it.source || (id&&id.includes('huggingface.co')?'hf':'github');
      const name = it.name || (id||'').split('/').pop();
      const base = {
        id, source, name,
        url: it.url || it.homepage || it.card_url,
        license: it.license || 'N/A',
        lang: it.lang || it.language || 'N/A',
        // Tags will be derived from authoritative task_keys first, then fuzzy fallback
        tags: [],
        categories: it.categories||{capabilities:[],scenes:[],lifecycle:[]},
        stats: it.stats||{},
        score: it.score||0,
        timeline: it.timeline||{t:[],stars:[],downloads:[]},
        summary: it.summary||'',
        summary_en: it.summary_en||'',
        summary_zh: it.summary_zh||'',
        summary_es: it.summary_es||'',
        updated_at: it.updated_at||new Date().toISOString()
      };
      // Prefer server-provided task_keys to avoid client overlabeling
      try{
        const providedKeys = Array.isArray(it.task_keys)? it.task_keys : [];
        let labels = [];
        if(providedKeys.length){
          labels = labelsFromTaskKeys(providedKeys);
          base.task_keys = providedKeys.slice();
        }
        if(labels.length===0){
          const keys = computeMatchedTaskKeys({ ...it, ...base });
          labels = labelsFromTaskKeys(keys);
          base.task_keys = Array.isArray(keys)? keys.slice() : [];
        }
        base.tags = labels.length>0 ? labels : (it.tags||[]).map(stdTagLabel);
      }catch{}
      // Keep old deriveCategories if needed (not used for tags)
      if ((!base.categories.capabilities?.length) && (!base.categories.scenes?.length) && (!base.categories.lifecycle?.length)) base.categories = deriveCategories(base);
      // Preserve special grouping/hotlist fields if provided by upstream data
      try{
        if(it && typeof it === 'object'){
          if(it.__group) base.__group = it.__group;
          if(it.__hot) base.__hot = it.__hot;
          if(it.category_key) base.category_key = it.category_key;
        }
      }catch{}
      return base;
    }

    async function init(){
  await loadCategories();
    await loadTaskMap();
      // Load date list for daily archives
      try{ availableDates = await fetch('../../data/ai/modelswatch/daily/dates.json', {cache:'no-store'}).then(r=>r.json()); if(!Array.isArray(availableDates)) availableDates = []; }catch{ availableDates = []; }
          // set bounds for native calendar (if we have dates)
      if(availableDates.length>0){
        dateInput.min = availableDates[availableDates.length-1];
        dateInput.max = availableDates[0];
        dateInput.value = availableDates[0];
        selectedDate = '';
      }
      // show date controls (always visible so users can pick a date; in GH/HF a separate "View snapshot" action loads snapshots)
      dateWrap.hidden = false;
      await loadDaily(selectedDate);
      render();
      sortEl.onchange = async ()=>{
        if(MODE==='daily'){
          if(!allLoaded) await loadAllDaily();
          setGlobalActive(true);
        }
        render();
      };
      qEl.addEventListener('input', async ()=>{
        query=qEl.value||'';
        if(MODE==='daily'){
          if(!allLoaded) await loadAllDaily();
          setGlobalActive(!!query);
        }
        render();
      });
      // toggle global view when cascader makes a selection or clears
      window.addEventListener('mw-global-toggle', async (e)=>{
        const on = !!(e?.detail?.on);
        if(MODE==='daily'){
          if(on && !allLoaded) await loadAllDaily();
          setGlobalActive(on);
          render();
        }
      });
  window.addEventListener('language-changed', ()=>{ render(); });
      // Mode switching
      modesEl.addEventListener('click', async (e)=>{
        const btn = e.target.closest('button[data-mode]');
        if(!btn) return;
        const mode = btn.getAttribute('data-mode');
        if(!mode || mode===MODE) return;
        MODE = mode;
        window.__mw_mode_current = mode;
        [...modesEl.querySelectorAll('button')].forEach(b=>{
          b.classList.toggle('primary', b===btn);
          b.classList.toggle('outline', b!==btn);
        });
        // Auto default sort per mode
        if(MODE==='gh'){ sortEl.value='score'; }
        else if(MODE==='hf'){ sortEl.value='score'; }
        else { sortEl.value='score'; }
          // Reset engineering/model-task selection on any mode change so GH/HF show the full hotlist by default
          try{
            // clear engineering single-select (GH) removed
          }catch{}
          try{
            // clear model/task multi-select (if present)
            if(typeof selectedTasks !== 'undefined' && selectedTasks && typeof selectedTasks.clear === 'function') selectedTasks.clear();
          }catch{}
          try{
            // clear any active search query so filterSort doesn't prefilter GH/HF
            query = '';
            if(typeof qEl !== 'undefined' && qEl) { qEl.value = ''; try{ qEl.dispatchEvent(new Event('input')); }catch{} }
          }catch{}
          try{
            // ensure global aggregation mode is off when switching modes
            if(typeof setGlobalActive === 'function') setGlobalActive(false);
          }catch{}
          try{
            // show a small transient hint to indicate filters cleared
            if(typeof showTransientHint === 'function') showTransientHint((getLang()==='zh')? '已清除筛选，显示全部热表' : (getLang()==='es')? 'Filtros borrados, mostrando todo' : 'Filters cleared — showing full hotlist');
          }catch{}
        if(MODE==='daily'){
          await loadDaily(selectedDate);
        }
        else if(MODE==='gh') await loadTopGH();
        else await loadTopHF();
        // Keep date controls visible for all modes; users can pick a date and click "View snapshot" when in GH/HF.
        if(MODE==='daily') setGlobalActive(false);
        try{ setTriggerLabelForMode(MODE); }catch{}
        updateTriggerLabel();
        updateClearButtonVisibility();
        try{ updateViewSnapshotButtonState(); }catch{}
        render();
      });

      // date interactions
        dateInput.addEventListener('change', async ()=>{
          const v = dateInput.value;
          selectedDate = (v && availableDates.includes(v)) ? v : '';
          if(MODE === 'daily'){
            await loadDaily(selectedDate);
            setGlobalActive(false);
          }
          try{ updateViewSnapshotButtonState(); }catch{}
          render();
        });
      prevBtn.addEventListener('click', async ()=>{
        if(availableDates.length===0) return;
        let cur = dateInput.value || availableDates[0];
        let idx = availableDates.indexOf(cur);
        if(idx<0) idx = 0;
        if(idx+1 < availableDates.length){
          dateInput.value = availableDates[idx+1];
          selectedDate = dateInput.value;
          if(MODE === 'daily'){
            await loadDaily(selectedDate);
            setGlobalActive(false);
          }
          try{ updateViewSnapshotButtonState(); }catch{}
          render();
        }
      });
      nextBtn.addEventListener('click', async ()=>{
        if(availableDates.length===0) return;
        let cur = dateInput.value || availableDates[0];
        let idx = availableDates.indexOf(cur);
        if(idx>0){
          dateInput.value = availableDates[idx-1];
          selectedDate = dateInput.value;
          if(MODE === 'daily'){
            await loadDaily(selectedDate);
            setGlobalActive(false);
          }
          try{ updateViewSnapshotButtonState(); }catch{}
          render();
        }
      });

      // View snapshot control (GH/HF): explicit action to load snapshot for selected date
      const viewSnapBtn = document.getElementById('mw-view-snapshot');
  const toggleAllBtn = document.getElementById('mw-toggle-all');
      // Compute a stable base label for the button per current language so we
      // don't rely on parsing DOM textContent which can be mutated.
      function computeSnapshotBaseLabel(){
        const L = getLang();
        if(L==='zh') return '查看快照';
        if(L==='es') return 'Ver instantánea';
        return 'View snapshot';
      }
      // Initialize base label and ensure the button shows it (no count yet).
      try{ if(viewSnapBtn){ viewSnapBtn.dataset.baseLabel = computeSnapshotBaseLabel(); viewSnapBtn.textContent = viewSnapBtn.dataset.baseLabel; } }catch{}

      function updateViewSnapshotButtonState(){
        try{
          if(!viewSnapBtn) return;
          // enabled when a date is selected and mode is gh or hf
          const enabled = !!selectedDate && (MODE==='gh' || MODE==='hf');
          viewSnapBtn.disabled = !enabled;
          viewSnapBtn.title = enabled ? 'View snapshot for selected date (will show number of items after loading)' : 'Select a date and switch to GH/HF to view snapshot';
          // When the selected date or mode changes, clear any previous snapshot count
          // because counts are tied to a specific date. Always show the base label.
          try{ viewSnapBtn.dataset.baseLabel = viewSnapBtn.dataset.baseLabel || computeSnapshotBaseLabel(); }catch{}
          try{ if(!enabled){ snapshotLastCount = 0; viewSnapBtn.textContent = viewSnapBtn.dataset.baseLabel; } else { /* enabled but no snapshot loaded yet */ snapshotLastCount = 0; viewSnapBtn.textContent = viewSnapBtn.dataset.baseLabel; } }catch{}
        }catch{}
      }
      if(viewSnapBtn){
        viewSnapBtn.addEventListener('click', async ()=>{
          if(!selectedDate){ alert('请选择有效日期以查看快照'); return; }
          if(!(MODE==='gh' || MODE==='hf')){ alert('请先切换到 工程热榜 或 模型实验场 模式'); return; }
          const ok = await loadSnapshotForMode(selectedDate, MODE);
          if(!ok){ alert('未找到对应日期的快照或快照不可用: ' + selectedDate); }
          else{
            // Show snapshot count in button for visibility using stable base label
            try{
              const base = viewSnapBtn.dataset.baseLabel || computeSnapshotBaseLabel();
              if(snapshotLastCount && typeof snapshotLastCount==='number'){
                viewSnapBtn.textContent = `${base} · ${snapshotLastCount}`;
              }else{
                viewSnapBtn.textContent = base;
              }
            }catch{}
          }
          render();
        });
        // Keep button language in sync when user changes language
        window.addEventListener('language-changed', ()=>{
          try{
            const base = computeSnapshotBaseLabel();
            viewSnapBtn.dataset.baseLabel = base;
            // If no count shown, ensure label updates; if count shown retain count suffix
            try{
              if(snapshotLastCount && typeof snapshotLastCount === 'number' && snapshotLastCount>0){ viewSnapBtn.textContent = `${base} · ${snapshotLastCount}`; }
              else { viewSnapBtn.textContent = base; }
            }catch{}
          }catch{}
        });
      }
      if(toggleAllBtn){
        toggleAllBtn.addEventListener('click', async ()=>{
          useAllDatesForFilter = !useAllDatesForFilter;
          toggleAllBtn.setAttribute('aria-pressed', useAllDatesForFilter? 'true' : 'false');
          // If enabling, ensure itemsAll is loaded (may be slow)
          if(useAllDatesForFilter){
            try{ if(!allLoaded) await loadAllDaily(); }catch{};
            try{ setDataSourceLabel('Daily', 'All dates'); }catch{}
          }else{
            // revert datasource label to current mode's label
            try{ if(MODE==='daily') setDataSourceLabel('Daily', window.__mw_updated_at||''); else setDataSourceLabel(MODE==='gh'?'Top List': 'Top List', window.__mw_updated_at||''); }catch{}
          }
          render();
        });
      }
      // Populate recent id cache in background (non-blocking): when ready, re-render to apply penalties
      try{ getRecentIdSet(RECENT_REPEAT_DAYS).then(()=>{ try{ render(); }catch{} }); }catch{}
    }

    init();
  })();
  </script>

  <!-- Script: Cascading category filter (三级分类筛选) -->
  <script>
    // ===== Cascader (三级分类筛选) =====
    const casWrap = document.querySelector('.mw-cas-inline');
    const clearBtn = document.getElementById('mw-cas-clear');
    const triggerBtn = document.getElementById('mw-cas-trigger');
  // Project categories (GH) removed — we only keep model-lab (HF) category UI
    // Project categories file and GH project browsing removed. No network fetch required.
    function setTriggerLabelForMode(mode){
  const lang = getLang();
      const cur = (window.__mw_mode_current || mode || MODE || '').toString().trim();
      if(cur==='hf'){
        triggerBtn.dataset.modeLabel='model';
        const zh='按类别查看模型', en='Browse Models by Category', es='Ver modelos por categoría';
        triggerBtn.innerHTML = `<span>${lang==='en'?en:lang==='es'?es:zh}</span>`;
      }else{
        triggerBtn.dataset.modeLabel='model';
        const zh='按类别查看', en='Browse by Category', es='Ver por categoría';
        triggerBtn.innerHTML = `<span>${lang==='en'?en:lang==='es'?es:zh}</span>`;
      }
    }
    // Show/hide the cascader trigger depending on mode (hide in daily)
    function showCascaderTriggerForMode(mode){
      try{
        if(!triggerBtn) return;
        const raw = (mode===undefined || mode===null) ? (window.__mw_mode_current||MODE||'') : mode;
        const m = String(raw||'').trim().toLowerCase();
        const prev = triggerBtn.style.display;
  // show cascader only in HF (模型实验场); hide in daily and GH
        if(m === 'hf'){
          triggerBtn.style.display = '';
        }else{
          triggerBtn.style.display = 'none';
        }
      }catch(e){ try{ console.warn('[mw] showCascaderTriggerForMode error', e); }catch{} }
    }
    window.addEventListener('language-changed', (e)=>{ try{ setTriggerLabelForMode(window.__mw_mode_current||'daily'); }catch{} });
    const dd = document.getElementById('mw-cas-dd');
    const col1 = document.getElementById('mw-cas-c1');
    const col2 = document.getElementById('mw-cas-c2');
    const col3 = document.getElementById('mw-cas-c3');
    const closeBtn = document.getElementById('mw-cas-close');
  // Global grid/sub header elements (restored after earlier refactor removal)
  const gridEl = document.getElementById('mw-grid');
  const subEl = document.getElementById('mw-sub');
  const toggleAllCasBtn = document.getElementById('mw-toggle-all-cas');
  let mobileStage = 0; let selCat = null, selSub = null; const selectedTasks = new Set();
    // Engineering (GitHub hotlist) single-select category filter state removed
  // Initialize immediately with builtin tree so UI renders instantly; remote JSON (if any) will hydrate later.
  let CAT_TREE = null; // will be assigned after BUILTIN_TREE declared
  let CAT_REMOTE_LOADED = false; // whether remote categories replaced builtin
  const labelOf = (obj)=> { if(!obj) return ''; const L = getLang(); return obj[L] || obj.zh || obj.en || obj.es || ''; }

    // Built-in fallback tree (partial) for robust UX if JSON cannot be loaded
  const BUILTIN_TREE = [
      {
        key: 'cv', zh: '计算机视觉', en: 'Computer Vision', es: 'Visión por Computadora',
        subcategories: [
          { key: 'general_visual_understanding', zh:'通用视觉理解', en:'General Visual Understanding', es:'Comprensión Visual General', tasks:[
            { key:'image_classification', zh:'图像分类', en:'Image Classification', es:'Clasificación de Imágenes' },
            { key:'object_detection', zh:'目标检测', en:'Object Detection', es:'Detección de Objetos' },
            { key:'semantic_segmentation', zh:'语义分割', en:'Semantic Segmentation', es:'Segmentación Semántica' },
            { key:'instance_segmentation', zh:'实例分割', en:'Instance Segmentation', es:'Segmentación de Instancias' },
            { key:'panoptic_segmentation', zh:'全景分割', en:'Panoptic Segmentation', es:'Segmentación Panóptica' }
          ]},
          { key:'generative_vision', zh:'生成式视觉', en:'Generative Vision', es:'Visión Generativa', tasks:[
            { key:'text_to_image', zh:'文生图（Diffusion/GAN）', en:'Text-to-Image (Diffusion/GAN)', es:'Texto-a-Imagen (Diffusion/GAN)' },
            { key:'text_to_video', zh:'文生视频', en:'Text-to-Video', es:'Texto-a-Vido' },
            { key:'3d_reconstruction', zh:'三维重建', en:'3D Reconstruction', es:'Reconstrucción 3D' },
            { key:'nerf', zh:'NeRF（神经辐射场）', en:'NeRF (Neural Radiance Fields)', es:'NeRF (Campos Radiantes Neuronales)' }
          ]},
          { key:'visual_quality_enhancement', zh:'视觉质量增强', en:'Visual Quality Enhancement', es:'Mejora de Calidad Visual', tasks:[
            { key:'super_resolution', zh:'图像/视频超分', en:'Image/Video Super-Resolution', es:'Sobreresolución de Imágenes/Videos' },
            { key:'denoising', zh:'图像/视频去噪', en:'Image/Video Denoising', es:'Reducción de Ruido en Imágenes/Videos' },
            { key:'restoration', zh:'图像/视频复原', en:'Image/Video Restoration', es:'Restauración de Imágenes/Videos' }
          ]},
          { key:'vertical_visual_applications', zh:'垂直视觉应用', en:'Vertical Visual Applications', es:'Aplicaciones Visuales Verticals', tasks:[
            { key:'medical_image_processing', zh:'医学影像处理', en:'Medical Image Processing', es:'Procesamiento de Imágenes Médicas' },
            { key:'remote_sensing_image_processing', zh:'遥感/工业影像处理', en:'Remote Sensing/Industrial Image Processing', es:'Procesamiento de Imágenes de Teledetección/Industriales' }
          ]},
          { key:'multimodal_visual_interaction', zh:'多模态视觉交互', en:'Multimodal Visual Interaction', es:'Interacción Visual Multimodal', tasks:[
            { key:'vqa', zh:'视觉问答（VQA）', en:'Visual Question Answering (VQA)', es:'Pregunta-Respuesta Visual (VQA)' },
            { key:'visual_grounding', zh:'视觉定位（Grounding）', en:'Visual Grounding', es:'Localización Visual (Grounding)' }
          ]},
          { key:'edge_visual_optimization', zh:'端侧视觉优化', en:'Edge-Side Visual Optimization', es:'Optimización Visual para Dispositivos Periféricos', tasks:[
            { key:'lightweight_visual_model', zh:'边缘端视觉模型轻量化', en:'Lightweight Visual Model for Edge Devices', es:'Modelo Visual Ligero para Dispositivos de Borde' }
          ]}
        ]
      },
      {
        key:'llm_nlp', zh:'大语言模型与自然语言处理', en:'Large Language Models & Natural Language Processing', es:'Modelos de Lenguaje Grande y Procesamiento de Lenguaje Natural',
        subcategories:[
          { key:'llm_foundation_training', zh:'LLM基础训练', en:'LLM Foundation Training', es:'Entrenamiento Básico de LLM', tasks:[
            { key:'llm_pretraining', zh:'语言建模（LLM预训练）', en:'Language Modeling (LLM Pre-training)', es:'Modelado de Lenguaje (Preentrenamiento de LLM)' }
          ]},
          { key:'llm_training_optimization', zh:'LLM训练优化', en:'LLM Training Optimization', es:'Optimización de Entrenamiento de LLM', tasks:[
            { key:'instruction_tuning', zh:'指令学习（Instruction Tuning）', en:'Instruction Tuning', es:'Ajuste por Instrucciones (Instruction Tuning)' }
          ]},
          { key:'llm_alignment_optimization', zh:'LLM对齐优化', en:'LLM Alignment Optimization', es:'Optimización de Alineación de LLM', tasks:[
            { key:'rlhf', zh:'RLHF（基于人类反馈的强化学习）', en:'RLHF (Reinforcement Learning from Human Feedback)', es:'RLHF (Aprendizaje por Refuerzo a partir de Retroalimentación Humana)' }
          ]},
          { key:'llm_capability_enhancement', zh:'LLM能力增强', en:'LLM Capability Enhancement', es:'Mejora de Capacidades de LLM', tasks:[
            { key:'rag', zh:'RAG（检索增强生成）', en:'RAG (Retrieval-Augmented Generation)', es:'RAG (Generación Mejorada por Recuperación)' }
          ]},
          { key:'llm_application_deployment', zh:'LLM应用落地', en:'LLM Application Deployment', es:'Despliegue de Aplicaciones de LLM', tasks:[
            { key:'code_generation', zh:'代码生成', en:'Code Generation', es:'Generación de Código' }
          ]},
          { key:'llm_complex_reasoning', zh:'LLM复杂推理', en:'LLM Complex Reasoning', es:'Razonamiento Complejo de LLM', tasks:[
            { key:'structured_reasoning', zh:'结构化推理', en:'Structured Reasoning', es:'Razonamiento Estructurado' },
            { key:'tool_use', zh:'工具调用（Tool Use）', en:'Tool Use', es:'Uso de Herramientas (Tool Use)' }
          ]},
          { key:'llm_efficient_fine_tuning', zh:'LLM高效微调', en:'LLM Efficient Fine-Tuning', es:'Ajuste Fino Eficiente de LLM', tasks:[
            { key:'lora_adapter', zh:'LoRA/Adapter（参数高效微调）', en:'LoRA/Adapter (Parameter-Efficient Fine-Tuning)', es:'LoRA/Adapter (Ajuste Fino Eficiente en Parámetros)' }
          ]},
          { key:'llm_cross_lingual', zh:'LLM跨语言能力', en:'LLM Cross-Lingual Capability', es:'Capacidad Multilingüe de LLM', tasks:[
            { key:'multilingual_processing', zh:'多语言处理', en:'Multilingual Processing', es:'Procesamiento Multilingüe' },
            { key:'low_resource_language', zh:'低资源语言处理', en:'Low-Resource Language Processing', es:'Procesamiento de Idiomas con Poca Recursos' }
          ]},
          { key:'llm_knowledge_management', zh:'LLM知识管理', en:'LLM Knowledge Management', es:'Gestión de Conocimiento de LLM', tasks:[
            { key:'knowledge_editing', zh:'知识编辑/注入', en:'Knowledge Editing/Injection', es:'Edición/Inyección de Conocimiento' }
          ]},
          { key:'llm_data_support', zh:'LLM数据支撑', en:'LLM Data Support', es:'Soporte de Datos para LLM', tasks:[
            { key:'nlp_data_synthesis', zh:'NLP数据合成', en:'NLP Data Synthesis', es:'Síntesis de Datos en PLN' },
            { key:'nlp_data_distillation', zh:'NLP数据蒸馏', en:'NLP Data Distillation', es:'Destilación de Datos en PLN' }
          ]},
          { key:'nlp_hci', zh:'NLP人机交互', en:'NLP Human-Computer Interaction', es:'Interacción Humano-Computadora en PLN', tasks:[
            { key:'dialogue_system_optimization', zh:'对话系统优化', en:'Dialogue System Optimization', es:'Optimización de Sistema de Diálogo' }
          ]},
          { key:'nlp_ethical_compliance', zh:'NLP伦理合规', en:'NLP Ethical Compliance', es:'Cumplimiento Ético en PLN', tasks:[
            { key:'nlp_bias_mitigation', zh:'NLP偏见检测与消除', en:'NLP Bias Detection and Mitigation', es:'Detección y Mitigación de Prejuicios en PLN' }
          ]}
        ]
      },
      {
        key:'multimodal_speech', zh:'多模态与语音', en:'Multimodal & Speech', es:'Multimodal y Voz',
        subcategories:[
          { key:'cross_modal_alignment', zh:'跨模态基础对齐', en:'Cross-Modal Foundation Alignment', es:'Alineación Básica Intermodal', tasks:[
            { key:'image_text_alignment', zh:'图文对齐（CLIP系）', en:'Image-Text Alignment (CLIP Series)', es:'Alineación Imagen-Texto (Serie CLIP)' }
          ]},
          { key:'multimodal_large_models', zh:'多模态大模型', en:'Multimodal Large Models', es:'Modelos Grandes Multimodales', tasks:[
            { key:'multimodal_understanding_generation', zh:'多模态理解与生成（GPT-4V/Flamingo）', en:'Multimodal Understanding & Generation (GPT-4V/Flamingo)', es:'Comprensión y Generación Multimodales (GPT-4V/Flamingo)' }
          ]},
          { key:'fundamental_speech_tech', zh:'语音基础技术', en:'Fundamental Speech Technologies', es:'Tecnologías Básicas de Voz', tasks:[
            { key:'asr', zh:'ASR（语音识别）', en:'ASR (Automatic Speech Recognition)', es:'ASR (Reconocimiento Automático de Voz)' },
            { key:'tts', zh:'TTS（语音合成）', en:'TTS (Text-to-Speech)', es:'TTS (Texto-a-Voz)' }
          ]},
          { key:'advanced_speech_understanding', zh:'语音深度理解', en:'Advanced Speech Understanding', es:'Comprensión Avanzada de Voz', tasks:[
            { key:'slu', zh:'SLU（语音理解）', en:'SLU (Spoken Language Understanding)', es:'SLU (Comprensión de Lenguaje Hablado)' }
          ]},
          { key:'speech_separation_recognition', zh:'语音分离与识别', en:'Speech Separation & Recognition', es:'Separación y Reconocimiento de Voz', tasks:[
            { key:'speaker_separation', zh:'说话人分离', en:'Speaker Separation', es:'Separación de Habitantes' },
            { key:'noise_separation', zh:'场景噪声分离', en:'Environmental Noise Separation', es:'Separación de Ruido Ambiental' }
          ]}
        ]
      }
    ];

    const CAT_CACHE_KEY = 'mw_cat_tree_v1';
    const CAT_CACHE_TTL = 1000 * 60 * 60 * 24 * 7; // 7 days
    function tryLoadCachedCats(){
      try{
        const raw = localStorage.getItem(CAT_CACHE_KEY); if(!raw) return false;
        const obj = JSON.parse(raw);
        if(!obj || !obj.ts || !Array.isArray(obj.data)) return false;
        if(Date.now() - obj.ts > CAT_CACHE_TTL) return false;
  CAT_TREE = obj.data; CAT_REMOTE_LOADED = true; return true;
      }catch{ return false; }
    }
    function cacheCats(){
      try{ if(CAT_REMOTE_LOADED && Array.isArray(CAT_TREE)){ localStorage.setItem(CAT_CACHE_KEY, JSON.stringify({ts:Date.now(), data:CAT_TREE})); } }catch{}
    }
    async function loadAiCategories(){
      if(CAT_REMOTE_LOADED) return true;
      const paths = [
        '../../data/ai/ai_categories.json', '/data/ai/ai_categories.json', '../data/ai/ai_categories.json', './data/ai/ai_categories.json'
      ];
      const controllers = [];
      const fetches = paths.map(p=>{
        const c = new AbortController(); controllers.push(c);
        const to = setTimeout(()=> c.abort(), 2500); // abort slow path
        return fetch(p,{cache:'no-store', signal:c.signal}).then(r=>{ clearTimeout(to); if(!r.ok) throw new Error('bad '+p); return r.text(); })
          .then(txt=>{ try{ const cj = JSON.parse(txt); if(cj?.categories) return cj.categories; throw 0; }catch{ throw new Error('parse '+p); }});
      });
      let cats = null;
      try{ cats = await Promise.any(fetches); }catch{ cats = null; }
      controllers.forEach(c=>{ try{ c.abort(); }catch{} });
      if(Array.isArray(cats) && cats.length){
  CAT_TREE = cats; CAT_REMOTE_LOADED = true; cacheCats();
        return true;
      }
      // if remote fails leave existing (builtin or cache) in place
      return false;
    }
    // Assign initial tree (builtin) before any rendering
    CAT_TREE = BUILTIN_TREE;
    // Attempt cache then background refresh (non-blocking)
    if(!tryLoadCachedCats()){
      // fire and forget
      loadAiCategories().then(changed=>{ if(changed && dd && !dd.hidden){ renderCol1(); renderCol2(); renderCol3(); } });
    }

    // Built-in labels for the six top-level categories (fallback labels when JSON fails or before load)
    const TOP_CATS = [
      { key: 'cv', zh: '计算机视觉', en: 'Computer Vision', es: 'Visión por Computadora' },
  { key: 'llm_nlp', zh: '大语言模型与自然语言处理', en: 'Large Language Models & Natural Language Processing', es: 'Modelos de Lenguaje Grande y Procesamiento de Lenguaje Natural' },
      { key: 'multimodal_speech', zh: '多模态与语音', en: 'Multimodal & Speech', es: 'Multimodal y Voz' },
  { key: 'graph_reco_retrieval', zh: '图网络、推荐与检索', en: 'Graph, Recommendation & Retrieval', es: 'Grafos, Recomendación y Recuperación' },
  { key: 'optimization_system_security', zh: '优化、系统与安全', en: 'Optimization, System & Security', es: 'Optimización, Sistemas y Seguridad' },
  { key: 'emerging_temporal', zh: '新兴交叉与时序模态', en: 'Emerging Interdisciplinary & Temporal Modalities', es: 'Interdisciplinario Emergente y Modalidades Temporales' }
    ];
  // TOP_CATS initialized

    // Safety: if cascader container missing, skip all without affecting rest of page
  if(!casWrap){ /* cascader container missing; skip cascader init */ }

    function findCatByKey(key){
      if(!CAT_TREE) return null;
      return CAT_TREE.find(c=> c.key===key) || null;
    }

    // Mobile navigation helpers
    function isMobile(){ return window.innerWidth <= 800; }
    function setMobileStage(stage){ 
      mobileStage = stage; 
      if(!isMobile()) return;
      [col1, col2, col3].forEach((col, i) => {
        col.className = col.className.replace(/stage-\w+/g, '');
        if(i === stage) col.classList.add('stage-active');
        else if(i < stage) col.classList.add('stage-hidden'); 
        else col.classList.add(`stage-${i}`);
      });
    }
    function updateMobileVisibility(){
      if(!isMobile()){
        // desktop ensure all visible
        [col1,col2,col3].forEach(c=>{ if(c) c.style.display='block'; });
        return;
      }
      if(mobileStage===0){
        if(col1) col1.style.display='block';
        if(col2) col2.style.display='none';
        if(col3) col3.style.display='none';
      }else if(mobileStage===1){
        if(col1) col1.style.display='none';
        if(col2) col2.style.display='block';
        if(col3) col3.style.display='none';
      }else{
        if(col1) col1.style.display='none';
        if(col2) col2.style.display='none';
        if(col3) col3.style.display='block';
      }
    }
    function addMobileNavHeader(col, title, canGoBack = false){
      if(!isMobile()) return;
      const nav = document.createElement('div'); nav.className = 'mw-mobile-nav';
      if(canGoBack){
        const back = document.createElement('button'); 
        back.className = 'mw-mobile-back';
        back.innerHTML = '← Back';
        back.addEventListener('click', ()=> setMobileStage(mobileStage - 1));
        nav.appendChild(back);
      }
      const titleEl = document.createElement('div'); titleEl.className = 'mw-mobile-title'; titleEl.textContent = title;
      nav.appendChild(titleEl);
      col.prepend(nav);
    }

    // Dropdown cascader rendering
    function renderCol1(){
      if(!casWrap||!col1) return;
  // renderCol1 start
      const list = document.createElement('div'); list.className = 'mw-list';
      if(!Array.isArray(TOP_CATS) || TOP_CATS.length===0){
        list.innerHTML = '<div class="mw-muted">(no categories)</div>';
        console.warn('[Cascader] TOP_CATS empty at renderCol1');
      }
      TOP_CATS.forEach(meta=>{
          // When a filter is active, only show top categories that contain
          // tasks with matched items according to window.__mw_task_counts.
          try{
            const counts = window.__mw_task_counts || {};
            const activeFilter = selectedTasks && selectedTasks.size>0;
            if(activeFilter){
              const cat = findCatByKey(meta.key);
              if(cat){
                let any = false;
                (cat.subcategories||[]).forEach(sub=>{
                  (sub.tasks||[]).forEach(t=>{ if((counts[t.key]||0) > 0) any = true; });
                });
                if(!any) return; // skip this top-level category
              }
            }
          }catch{}
          // render item: meta.key
          const item = document.createElement('div'); item.className = 'mw-item' + (selCat===meta.key?' active':''); item.dataset.key = meta.key;
          let lbl = labelOf(meta);
          if(!lbl){
            console.warn('[Cascader] empty label for top category key=', meta.key, meta);
            lbl = meta.key || '(?)';
          }
          item.textContent = lbl;
          item.addEventListener('click', (e)=>{
            e.stopPropagation();
            selCat = meta.key; selSub = null; // reset second level when switching
            // fast background load (already triggered on init); if still not remote loaded, try again but don't block UI
            if(!CAT_REMOTE_LOADED){ loadAiCategories().then(changed=>{ if(changed){ if(selCat===meta.key) { renderCol2(); renderCol3(); }}}); }
            renderCol1(); renderCol2(); renderCol3();
            if(isMobile()) setMobileStage(1);
          });
          list.appendChild(item);
      });
      col1.innerHTML = ''; 
      if(isMobile()) addMobileNavHeader(col1, 'Categories');
      col1.appendChild(list);
      updateMobileVisibility();
    }

    function renderCol2(){
      if(!casWrap||!col2) return;
      col2.innerHTML = '';
      const cat = selCat && findCatByKey(selCat);
      if(!cat){ col2.innerHTML = '<div class="mw-muted">—</div>'; return; }
      if(isMobile()) addMobileNavHeader(col2, labelOf(cat), true);
      const list = document.createElement('div'); list.className = 'mw-list';
      (cat.subcategories||[]).forEach(sub=>{
        try{
          const counts = window.__mw_task_counts || {};
          const activeFilter = selectedTasks && selectedTasks.size>0;
          if(activeFilter){
            // skip subcategories that have no tasks with matched items
            let any = false;
            (sub.tasks||[]).forEach(t=>{ if((counts[t.key]||0) > 0) any = true; });
            if(!any) return;
          }
        }catch{}
        const item = document.createElement('div'); item.className = 'mw-item' + (selSub===sub.key?' active':''); item.dataset.key = sub.key;
        item.textContent = labelOf(sub);
        item.addEventListener('click', (e)=>{ 
          e.stopPropagation();
          selSub = sub.key; renderCol2(); renderCol3(); 
          if(isMobile()) setMobileStage(2);
        });
        list.appendChild(item);
      });
      col2.appendChild(list);
      updateMobileVisibility();
    }

    function renderCol3(){
      if(!casWrap||!col3) return;
      col3.innerHTML = '';
      const cat = selCat && findCatByKey(selCat);
      const sub = (cat?.subcategories||[]).find(s=> s.key===selSub);
      if(!sub){ col3.innerHTML = '<div class="mw-muted">—</div>'; return; }
      if(isMobile()) addMobileNavHeader(col3, labelOf(sub), true);
      const list = document.createElement('div'); list.className = 'mw-list';
      (sub.tasks||[]).forEach(tsk=>{
        try{
          const counts = window.__mw_task_counts || {};
          const activeFilter = selectedTasks && selectedTasks.size>0;
          if(activeFilter && ((counts[tsk.key]||0) === 0)) return; // hide tasks with zero matches
        }catch{}
        const item = document.createElement('div'); item.className = 'mw-item' + (selectedTasks.has(tsk.key)?' active':'');
        const box = document.createElement('span'); box.className = 'mw-check'; box.dataset.on = selectedTasks.has(tsk.key)?'1':'0'; box.innerHTML = selectedTasks.has(tsk.key)?'✓':'';
        const label = document.createElement('span'); label.textContent = labelOf(tsk);
        item.appendChild(box); item.appendChild(label);
        const toggle = (e)=>{
          e?.stopPropagation();
          if(selectedTasks.has(tsk.key)) selectedTasks.delete(tsk.key); else selectedTasks.add(tsk.key);
          // Do not apply filter immediately. Apply only when user clicks "应用筛选".
          renderCol3(); updateTriggerLabel();
          // Ensure clear button visibility updates immediately after task selection
          try{ updateClearButtonVisibility(); }catch{}
        };
        item.addEventListener('click', toggle);
        list.appendChild(item);
      });
      col3.appendChild(list);
      updateMobileVisibility();
    }

    function openDropdown(){
      if(!dd) return;
      dd.hidden = false;
      mobileStage = 0;
      dd.classList.remove('mw-single-col');
      if(col2) col2.style.display='';
      if(col3) col3.style.display='';
      renderCol1(); renderCol2(); renderCol3();
      if(isMobile()) { setMobileStage(0); updateMobileVisibility(); }
      setTimeout(()=> document.addEventListener('click', outsideClose),0);
    }
    function closeDropdown(){ if(!dd) return; dd.hidden = true; document.removeEventListener('click', outsideClose); }
    function outsideClose(e){ if(!dd) return; if(!dd.contains(e.target) && e.target!==triggerBtn && !triggerBtn?.contains(e.target)) closeDropdown(); }
    if(triggerBtn){ triggerBtn.addEventListener('click', e=>{ e.stopPropagation(); if(dd?.hidden) openDropdown(); else closeDropdown(); }); }
    if(closeBtn){
      closeBtn.addEventListener('click', async ()=>{
        try{
          const mode = window.__mw_mode_current || MODE;
          if(mode === 'hf'){
            // For HF (model lab), render then apply DOM-level filter so selectedTasks take effect.
            closeDropdown();
            try{ render(); }catch{}
            try{ 
              // Ensure the cascader columns are refreshed so the visible category/task
              // names reflect the new filtered dataset (window.__mw_task_counts).
              try{ renderCol1(); renderCol2(); renderCol3(); }catch{}
              setTimeout(()=>{ try{ applyFilter(); updateClearButtonVisibility(); }catch{} }, 0);
            }catch{}
            return;
          }
          // For daily mode: if cross-date toggle is active, ensure data loaded.
          if(mode === 'daily'){
            if(useAllDatesForFilter && !allLoaded){
              const progEl = document.getElementById('mw-load-progress');
              if(progEl){ progEl.style.display='inline'; progEl.textContent = '加载中…'; }
              try{ await loadAllDaily((loaded,total)=>{ if(progEl) progEl.textContent = `加载中… ${loaded}/${total}`; }); }catch(e){}
              if(progEl){ progEl.style.display='none'; progEl.textContent=''; }
            }
            try{ window.dispatchEvent(new CustomEvent('mw-global-toggle',{detail:{on: selectedTasks.size>0}})); }catch{}
            closeDropdown();
            try{ render(); }catch{}
            return;
          }
        }catch(e){ }
      });
    }

    // Cascader 'All dates' toggle handling (placed near cascader init)
    if(toggleAllCasBtn){
      toggleAllCasBtn.addEventListener('click', async (e)=>{
        e.stopPropagation();
        useAllDatesForFilter = !useAllDatesForFilter;
        toggleAllCasBtn.setAttribute('aria-pressed', useAllDatesForFilter? 'true':'false');
        toggleAllCasBtn.classList.toggle('active', useAllDatesForFilter);
        const progEl = document.getElementById('mw-load-progress');
        try{
          if(useAllDatesForFilter){
              // show loading UI
              try{ toggleAllCasBtn.disabled = true; }catch{}
              if(progEl){ progEl.style.display='inline'; progEl.textContent = '加载中…'; }
              // If current mode is HF, prefer the prebuilt HF aggregation for speed
              if((window.__mw_mode_current||MODE) === 'hf'){
                try{
                  const ok = await loadAllHF();
                  if(!ok) { console.warn('[mw] loadAllHF failed, falling back to loadAllDaily'); await loadAllDaily(); }
                  try{ setDataSourceLabel('Daily', 'All dates'); }catch{}
                }catch(e){ console.warn('[mw] loadAllHF error', e); await loadAllDaily(); }
              }else{
                // load with progress callback for daily
                await loadAllDaily((loaded, total)=>{
                  try{ if(progEl){ progEl.textContent = `加载中… ${loaded}/${total}`; } }catch{};
                });
                try{ setDataSourceLabel('Daily', 'All dates'); }catch{}
              }
            }else{
              try{ if(MODE==='daily') setDataSourceLabel('Daily', window.__mw_updated_at||''); else setDataSourceLabel(MODE==='gh'?'Top List':'Top List', window.__mw_updated_at||''); }catch{}
            }
        }catch(e){ console.warn('[mw] loadAllDaily error', e); }
        finally{
          try{ toggleAllCasBtn.disabled = false; }catch{}
          if(progEl){
            setTimeout(()=>{
              try{
                progEl.style.display = useAllDatesForFilter? 'inline' : 'none';
                if(!useAllDatesForFilter) progEl.textContent = '';
              }catch{}
            }, 400);
          }
        }
        render();
      });
    }

    function normalize(str){ return String(str||'').trim().toLowerCase(); }

    function itemMatchesTasks(cardEl){
      if(!selectedTasks || selectedTasks.size===0) return true;
      try{
        // Prefer explicit data-task-keys attribute if present on the card
        const dk = cardEl.getAttribute && cardEl.getAttribute('data-task-keys');
        if(dk){
          const keys = dk.split(/\s+/).filter(Boolean);
          for(const k of keys){ if(selectedTasks.has(k)) return true; }
        }
      }catch{}
      // Fallback: Collect visible labels (from tags inside the card)
      try{
        const tagEls = cardEl.querySelectorAll('.mw-tags .tag');
        const labels = new Set();
        tagEls.forEach(t=> labels.add(normalize(t.textContent)));
        const title = normalize(cardEl.querySelector('.mw-title')?.textContent||'');
        const sum = normalize(cardEl.querySelector('.muted')?.textContent||'');
        // Build label set of selected tasks (current language first, but fallback all languages)
        const want = new Set();
        const map = new Map(); // key -> {zh,en,es}
        CAT_TREE?.forEach(c=> (c.subcategories||[]).forEach(s=> (s.tasks||[]).forEach(t=>{ map.set(t.key, t); })));
        selectedTasks.forEach(k=>{ const t = map.get(k)||{}; ['zh','en','es'].forEach(L=>{ if(t[L]) want.add(normalize(t[L])); }); });
        for(const w of want){ if(labels.has(w) || title.includes(w) || sum.includes(w)) return true; }
      }catch{}
      return false;
    }

    function applyFilter(){
      // Show/hide cards and add highlight class
      const cards = gridEl.querySelectorAll('.mw-card');
      let shown = 0;
  const curMode = (window.__mw_mode_current || MODE || '').toString().trim();
  // GH project-category browsing removed; no group requirement
  const requireGroup = false;
      cards.forEach(card=>{
        const hitTasks = itemMatchesTasks(card);
        let ok = hitTasks;
        // GH group filtering removed
        card.style.display = ok? '' : 'none';
        card.classList.toggle('mw-hit', ok && selectedTasks.size>0);
        if(ok) shown++;
      });
      // Update subtle count suffix
      try{
        const L = getLang();
        const suffix = (selectedTasks.size>0) ? (L==='en'? ` · Filtered ${shown}` : L==='es'? ` · Filtrado ${shown}` : ` · 已筛选 ${shown} 项`) : '';
        // Always compute fresh base from current text (strip previous suffix if exists)
        const current = subEl.textContent || '';
        const base = current.replace(/\s·\s(已筛选|Filtered|Filtrado).*$/, '');
        subEl.setAttribute('data-base', base);
        subEl.textContent = base + suffix;
      }catch{}
      try{ cleanEmptyGroups(); }catch{}
    }

    // Remove any empty grouping sections (details.mw-hot-group) that contain
    // no visible cards. This helps ensure category headings disappear when
    // filters leave their group empty.
    function cleanEmptyGroups(){
      try{
        const groups = gridEl.querySelectorAll('details.mw-hot-group');
        groups.forEach(g=>{
          try{
            const innerGrid = g.querySelector('.mw-grid');
            if(!innerGrid) return;
            // Count visible cards inside this group's grid
            const cards = Array.from(innerGrid.querySelectorAll('.mw-card'));
            const anyVisible = cards.some(c => {
              try{ return c.offsetParent !== null && getComputedStyle(c).display !== 'none'; }catch{ return false; }
            });
            if(!anyVisible){
              g.remove();
            }
          }catch{}
        });
      }catch{}
    }

    // Re-apply filter whenever grid re-renders (mode switch, search, date change)
    const mo = new MutationObserver(()=>{ applyFilter(); });
    mo.observe(gridEl, { childList: true, subtree: false });

    // Clear selection
    clearBtn.addEventListener('click', ()=>{
  // Reset cascader tasks, model picker, search, and sort
  selectedTasks.clear();
      updateTriggerLabel();
      const qEl = document.getElementById('mw-q'); if(qEl){ qEl.value=''; }
      const sortEl = document.getElementById('mw-sort'); if(sortEl){ sortEl.value='score'; }
      applyFilter();
      // trigger top-level re-render to apply search/sort reset
      try{ const evt = new Event('input'); qEl?.dispatchEvent(evt); }catch{}
      // Notify main to exit global mode
      try{ window.dispatchEvent(new CustomEvent('mw-global-toggle',{detail:{on:false}})); }catch{}
      updateClearButtonVisibility();
    });


    function updateTriggerLabel(){
      if(!triggerBtn) return;
      const mode = window.__mw_mode_current||'daily';
      // Only provide model-lab label; GH category browsing removed so do not show engineering label
      const cnt = selectedTasks.size;
      const zh = triggerBtn.querySelector('.i18n.l-zh'); if(zh) zh.textContent = `按类别查看模型${cnt>0?` (${cnt})`:''}`;
      const en = triggerBtn.querySelector('.i18n.l-en'); if(en) en.textContent = `Browse Models by Category${cnt>0?` (${cnt})`:''}`;
      const es = triggerBtn.querySelector('.i18n.l-es'); if(es) es.textContent = `Ver modelos por categoría${cnt>0?` (${cnt})`:''}`;
      triggerBtn.classList.toggle('active', cnt>0);
    }

    function updateClearButtonVisibility(){
      if(!clearBtn) return;
      const mode = window.__mw_mode_current||'daily';
      // Show clear button only when a task selection (model lab) is active
      const filtered = selectedTasks.size>0;
      clearBtn.style.display = filtered ? '' : 'none';
    }

    // renderEngineeringCategories removed — GH project category browsing is no longer supported in this build

    // Rebuild labels on language change and update counts
    window.addEventListener('language-changed', ()=>{ if(!dd.hidden){ renderCol1(); renderCol2(); renderCol3(); } updateTriggerLabel(); });
    
    // Handle resize/orientation changes
    window.addEventListener('resize', ()=>{ 
      if(!dd.hidden){ 
        renderCol1(); renderCol2(); renderCol3(); 
        if(isMobile()) setMobileStage(mobileStage);
      } 
    });

    // Bootstrap cascader after DOM ready
    (function initCascader(){
      try{
        if(!casWrap) return; // silent skip
        renderCol1(); renderCol2(); renderCol3(); updateTriggerLabel();
      }catch(err){ console.error('[Cascader] init failed', err); }
    })();

    // Init
    (async function(){
      // initial lazy state: do not force load; render top column immediately
      renderCol1(); renderCol2(); renderCol3();
      applyFilter(); updateTriggerLabel();
    })();
    // Robust enforcement: re-apply cascader trigger visibility after navigation/load/hash changes and a couple of timed retries.
    (function enforceCascaderVisibility(){
      function applyFromUrl(){
        try{
          const params = new URLSearchParams(window.location.search || '');
          const p = (params.get('mode')||'').toString().trim().toLowerCase();
          const candidate = p || (window.__mw_mode_current||'') || (typeof MODE !== 'undefined' ? MODE : '');
          showCascaderTriggerForMode(candidate || 'daily');
          try{ /* cascader visibility enforced */ }catch(e){}
        }catch(e){ try{ console.warn('[mw] enforceCascaderVisibility error', e); }catch{} }
      }
      window.addEventListener('popstate', applyFromUrl);
      window.addEventListener('hashchange', applyFromUrl);
      window.addEventListener('load', applyFromUrl);
      // run a few times after load to catch late initializers
      setTimeout(applyFromUrl, 120);
      setTimeout(applyFromUrl, 600);
      // also run immediately once
      applyFromUrl();
    })();
  </script>
</body>
</html>
